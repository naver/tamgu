# Τύπος Γραμματικής

Ο τύπος `grammar` έχει σχεδιαστεί για να παρέχει στους προγραμματιστές έναν ισχυρό τρόπο περιγραφής πολύπλοκων δομών συμβολοσειρών. Είναι ιδιαίτερα χρήσιμο για τον εντοπισμό συγκεκριμένων υποσυμβολοσειρών σε ένα κείμενο που περιλαμβάνουν ψηφία, κεφαλαία γράμματα ή σημεία στίξης με αυστηρή σειρά.

## Μέθοδοι

Υπάρχουν δύο συναρτήσεις που εκτίθενται από αυτόν τον τύπο:

1. `apply(string|vector)`: Εφαρμόζει μια γραμματική σε ένα κείμενο, μετατρέποντάς το σε ένα διάνυσμα χαρακτήρων ή ένα διάνυσμα διακριτικών.
2. `load(rule, int skipblanks)`: Φορτώνει κανόνες ως συμβολοσειρά ή ως διάνυσμα κανόνων. Ο προαιρετικός παράμετρος `skipblanks` μπορεί να έχει τις τιμές:
   - 0: Όλοι οι χαρακτήρες λαμβάνονται υπόψη στη γραμματική. Αυτή είναι η προεπιλεγμένη τιμή όταν παραλείπεται το `skipblanks`.
   - 1: Τα κενά και οι καρτέλες αγνοούνται αυτόματα πριν από την εφαρμογή ενός στόχου σε υποσυμβολοσειρές. Οι χαρακτήρες στο τέλος των συμβολοσειρών αγνοούνται επίσης.
   - 2: Όλα τα κενά, συμπεριλαμβανομένων των αλλαγών γραμμής, αγνοούνται.

Ο τελεστής "in" μπορεί επίσης να χρησιμοποιηθεί με μια γραμματική για να εντοπίσει εάν μια συμβολοσειρά είναι συμβατή με τη γραμματική.

## Κανόνες

Οι κανόνες μπορούν να εφαρμοστούν είτε ως μια μεμονωμένη συμβολοσειρά είτε ως ένα διάνυσμα συμβολοσειρών, όπου κάθε συμβολοσειρά αντιπροσωπεύει έναν κανόνα.

### Μορφή Κανόνα

Η μορφή ενός κανόνα είναι ως εξής:

```
head := (~) element [,;] element .
```

όπου `element` μπορεί να είναι:
- Μια συμβολοσειρά: Κλεισμένη σε εισαγωγικά ή μονά εισαγωγικά.
- ? : Οποιοσδήποτε χαρακτήρας.
- %a : Οποιοσδήποτε αλφαβητικός χαρακτήρας.
- %c : Οποιοσδήποτε πεζός χαρακτήρας.
- %C : Οποιοσδήποτε κεφαλαίος χαρακτήρας.
- %d : Ένα ψηφίο.
- %e : Ένας χαρακτήρας emoji.
- %H : Ένας χαρακτήρας Hangul.
- %r : Ένας χαρακτήρας αλλαγής γραμμής.
- %s : Ένας χαρακτήρας κενού.
- %S : Ένας χαρακτήρας διαχωριστής (κενό ή αλλαγή γραμμής).
- %p : Ένα σημείο στίξης.
- %? : Ο χαρακτήρας "?".
- %% : Ο χαρακτήρας "%".
- 0, 1, 2, ..., 9 : Οποιοδήποτε ψηφίο, αναπαρίσταται από τον κωδικό χαρακτήρα του.
- $string : Μια συμβολοσειρά οποιασδήποτε μήκους (ίδια με το "string").
- head : Το κεφάλι ενός άλλου κανόνα.

Αρνητικότητα: Όλα τα στοιχεία μπορούν να αρνηθούν με το "~", εκτός από τα κεφάλια.

Απόφαση: Χρησιμοποιήστε το ";" όταν χρειάζεστε μια απόφαση μεταξύ δύο στοιχείων, "," αλλιώς.

Αστερίσκος Kleene: Χρησιμοποιήστε "+" ή "*" για να επαναλάβετε για κάθε ένα από αυτά τα στοιχεία.

Μεγαλύτερη αντιστοιχία: Εάν χρησιμοποιήσετε "++" ή "**", η επανάληψη θα καταναλώσει τη συμβολοσειρά μέχρι το πιο προσβάσιμο στοιχείο.

Προαιρετικό: Χρησιμοποιήστε "(element)" για προαιρετικούς χαρακτήρες ή κεφαλίδες.

Όλοι οι κανόνες πρέπει να τελειώνουν με ".".

Όταν το όνομα μιας κεφαλίδας ξεκινά με "_", η συμβολοσειρά εξάγεται αλλά η ετικέτα της δεν αποθηκεύεται.

Ειδικές περιπτώσεις:
- ?_ : Οποιοσδήποτε χαρακτήρας, αλλά δεν αποθηκεύεται.
- %a_ : Οποιοσδήποτε αλφαβητικός χαρακτήρας, αλλά δεν αποθηκεύεται.
- %c_ : Οποιοσδήποτε πεζός χαρακτήρας, αλλά δεν αποθηκεύεται.
- %C_ : Οποιοσδήποτε κεφαλαίος χαρακτήρας, αλλά δεν αποθηκεύεται.
- %d_ : Ένα ψηφίο, αλλά δεν αποθηκεύεται.
- %e_ : Ένα emoji, αλλά δεν αποθηκεύεται.
- %H_ : Ένας χαρακτήρας Hangul, αλλά δεν αποθηκεύεται.
- %r_ : Ένας χαρακτήρας αλλαγής γραμμής, αλλά δεν αποθηκεύεται.
- %s_ : Ένας χαρακτήρας κενού, αλλά δεν αποθηκεύεται.
- %S_ : Ένας χαρακτήρας διαχωριστής, αλλά δεν αποθηκεύεται.
- %p_ : Ένα σημείο στίξης, αλλά δεν αποθηκεύεται.
- label_ : Κλήση ενός κανόνα χωρίς αποθήκευση.

Η προσθήκη ενός "_" στο τέλος αυτών των επιλογών επιτρέπει την αναγνώριση ενός χαρακτήρα ή μιας ομάδας χαρακτήρων που δεν αποθηκεύονται στο τελικό αποτέλεσμα.

### Παράδειγμα

```python
# Αυτή η γραμματική αναγνωρίζει μια λέξη ή έναν αριθμό, μόνο για μια συμβολοσειρά...
string r = @"
bloc := word;number.
word := %a+.
number := %d+.
"@;

# Φορτώνουμε τη γραμματική μας
grammar g(r);

# Εφαρμόζουμε τη γραμματική στη συμβολοσειρά "the"
map m = g.apply("the")
# Αποτέλεσμα: {'bloc':[{'word':['the']}]}

m = g.apply("123")
# Αποτέλεσμα: {'bloc':[{'number':['123']}]}

# Ωστόσο, αν εφαρμόσουμε αυτήν τη γραμματική στο "Test 123", θα αποτύχει. Χρειαζόμαστε να προσθέσουμε
# δύο πράγματα στη γραμματική:
# α) Λαμβάνουμε υπόψη τα κενά
# β) Επαναλαμβάνουμε για να αναγνωρίσουμε κάθε διακριτικό στη συμβολοσειρά
string r = @"
base := bloc+.
bloc := word;number;%s.
word := %a+.
number := %d+.
"@;

# Έχουμε προσθέσει μια νέα απόφαση με %s για να λάβουμε υπόψη τα κενά. Στη συνέχεια
# προσθέσαμε έναν κανόνα "base" που επαναλαμβάνεται στο bloc.
m = g.apply("Test 123")
# Αποτέλεσμα: {'base':[{'bloc':[{'word':['Test']}]},{'bloc':[' ']},{'bloc':[{'number':['123']}]}]}

# Μπορούμε να χρησιμοποιήσουμε τον τελεστή "_" για να αφαιρέσουμε περιττές πληροφορίες από την έξοδο, όπως το "bloc".
string r = @"
base := _bloc+.
_bloc := word;number;%s.
word := %a+.
number := %d+.
"@;

m = g.apply("Test 123")
# Αποτέλεσμα: {'base':[{'word':['Test']},' ',{'number':['123']}]}
```

## Υπο-γραμματικές

Οι υπο-γραμματικές εισάγονται μεταξύ "[...]". Σε αυτές τις αγκύλες, είναι δυνατή η καθορισμός μιας απόφασης από χαρακτήρες συνήθους έκφρασης. Αυτές οι εκφράσεις είναι ιδιαίτερα χρήσιμες όταν εφαρμόζουμε μια γραμματική σε ένα διάνυσμα συμβολοσειρών, όπου οι συμβολοσειρές μπορούν να αντιστοιχηθούν στο επίπεδο χαρακτήρων έναντι της ίδιας της έκφρασης. Κάθε έκφραση πρέπει να χωρίζεται από την επόμενη με ένα "|". Δεν μπορείτε να καλέσετε έναν κανόνα από μέσα στις αγκύλες, οπότε μια συμβολοσειρά όπως "dog" θα είναι ισοδύναμη με "$dog".

### Παράδειγμα

```python
string dico = @"
test := %a, wrd,%a.
wrd := [%C,(" -"),%c+|test|be|dog|cat].
"@;

grammar g(dico);
ustring s = "The C -at drinks";
uvector v = s.tokenize();
vector res = g.apply(v);
println(res);
```

## Διάνυσμα έναντι Χάρτη

Εάν η μεταβλητή παραλήπτη αντικατασταθεί με ένα διάνυσμα, η δομή της έξοδου είναι διαφορετική. Το όνομα του κανόνα κεφαλής εισάγεται στην τελική δομή ως το πρώτο στοιχείο. Για παράδειγμα, εάν εφαρμόσουμε τη γραμματική στην ίδια συμβολοσειρά αλλά με ένα διάνυσμα ως έξοδο, λαμβάνουμε: `['base',['word','Test'],' ',['number','123'],' ',['code','T234e']]`.

## Η είσοδος είναι συμβολοσειρά ή διάνυσμα

Εάν η είσοδος είναι μια συμβολοσειρά, κάθε εντοπισμένος χαρακτήρας προσαρτάται στη συμβολοσειρά εξόδου. Ωστόσο, εάν η είσοδος είναι ένα διάνυσμα χαρακτήρων, το αποτέλεσμα της έξοδου διατηρείται ως διάνυσμα χαρακτήρων.

### Παράδειγμα

```python
# Αυτή η γραμματική αναγνωρίζει μια λέξη ή έναν αριθμό
string r = @"
base := _bloc+.
_bloc := code;word;number;%s.
word := %a+.
number := %d+.
code := %C,%d+,%c.
"@;

# Φορτώνουμε τη γραμματική μας
grammar g(r);

# Διαχωρίζουμε μια συμβολοσειρά σε ένα διάνυσμα χαρακτήρων
string s = "Test 123 T234e";
svector vs = s.split("");

# Εφαρμόζουμε τη γραμματική στο διάνυσμα χαρακτήρων
vector v = g.apply(vs);
println(v);
```

## Συνάρτηση

Είναι δυνατόν να συσχετιστεί μια συνάρτηση με μια γραμματική. Η υπογραφή της συνάρτησης είναι ως εξής: `function grammarcall(string head, self structure, int pos)`. Αυτή η συνάρτηση καλείται για κάθε νέα δομή που υπολογίζεται για ένα συγκεκριμένο κεφάλαιο. Εάν αυτή η συνάρτηση επιστρέψει false, τότε η ανάλυση αυτού του κανόνα αποτυγχάνει. Το `pos` είναι η τελευταία θέση στη συμβολοσειρά μέχρι την οποία έχει γίνει ανάλυση.

### Παράδειγμα

```python
# Αυτή η γραμματική αναγνωρίζει μια λέξη ή έναν αριθμό
string r = @"
base := _bloc+.
_bloc := code;word;number;%s.
word := %a+.
number := %d+.
code := %C,%d+,%c.
"@;

# Αυτή η συνάρτηση καλείται για κάθε νέο κανόνα που επιτυγχάνει
function callgrm(string head, self v, int ps) {
    println(head,v,ps);
    return true;
}

# Φορτώνουμε τη γραμματική μας
grammar g(r) with callgrm;

# Διαχωρίζουμε μια συμβολοσειρά σε ένα διάνυσμα χαρακτήρων
string s = "Test 123 T234e";

# Εφαρμόζουμε τη γραμματική στη συμβολοσειρά
map m = g.apply(s);
println(m);
```

## Τροποποίηση της Δομής

Η δομή μπορεί επίσης να τροποποιηθεί στη συνάρτηση που συσχετίζεται με τη γραμματική, αλλά πρέπει να ασκηθεί προσοχή κατά την πραγματοποίηση τροποποιήσεων.

### Παράδειγμα

```python
function callgrm(string head, self v, int ps) {
    # Εάν το κεφάλι είναι μια λέξη, τροποποιούμε την εσωτερική συμβολοσειρά
    if (head == "word") {
        println(head,v);
        v[0] += "_aword";
    }
    return true;
}
```

## Από Μέσα σε έναν Κανόνα

Μια συνάρτηση μπορεί επίσης να κληθεί από μέσα σε έναν κανόνα. Η υπογραφή είναι ως εξής: `function rulecall(self structure, int pos)`.

### Παράδειγμα

```python
# Αυτή η γραμματική αναγνωρίζει μια λέξη ή έναν αριθμό
string r = @"
base := _bloc+.
_bloc := code;word;number;%s.
word := %a+.
number := %d+.
code := %C,%d+,%c,callcode.
"@;

# Φορτώνουμε τη γραμματική μας
grammar g(r);

# Διαχωρίζουμε μια συμβολοσειρά σε ένα διάνυσμα χαρακτήρων
string s = "Test 123 T234e";

# Εφαρμόζουμε τη γραμματική στο διάνυσμα χαρακτήρων
map m = g.apply(s);
println(m);
```

## Ανάλυση HTML

```python
# Η evaluate είναι μια βασική μέθοδος για την αντικατάσταση κάθε οντότητας HTML με το αντίστοιχο UTF8.
function evalue(self s, int p) {
    s[1] = s[1].evaluate();
    return true;
}

# Αυτή είναι η γραμματική HTML μας
# Δεν διατηρούμε χαρακτήρες κενού μεταξύ ετικετών, για αυτό: %s_ στο object
string htmlgrm = @"
html := _object+.
_object := tag;%s_;text.
tag := "<",?+,">".
text := _characters,evalue.
_characters := ~"<"+.
"@;

# Συντάσσουμε τη γραμματική μας
grammar ghtml(htmlgrm);

# Εφαρμόζουμε τη γραμματική σε ένα κείμενο HTML
vector rgram = ghtml.apply(html_text);
```