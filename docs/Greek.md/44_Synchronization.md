# Συγχρονισμός

Το Tamgu παρέχει έναν απλό τρόπο για την τοποθέτηση νημάτων σε κατάσταση αναμονής. Η διαδικασία είναι πολύ απλή στην υλοποίηση. Το Tamgu παρέχει διάφορες συναρτήσεις για αυτόν τον σκοπό:

## Μέθοδοι

1. `cast(string)`: Αυτή η εντολή απελευθερώνει την εκτέλεση όλων των νημάτων που περιμένουν για το συγκεκριμένο string.
2. `cast()`: Αυτή η εντολή απελευθερώνει όλα τα νήματα, ανεξάρτητα από την κατάστασή τους.
3. `lock(string s)`: Αυτή η εντολή βάζει κλείδωμα σε ένα τμήμα κώδικα για να αποτρέψει δύο νήματα από την πρόσβαση στις ίδιες γραμμές ταυτόχρονα.
4. `unlock(string s)`: Αυτή η εντολή αφαιρεί το κλείδωμα για να επιτρέψει σε άλλα νήματα να έχουν πρόσβαση στο περιεχόμενο μιας συνάρτησης.
5. `waitonfalse(var)`: Αυτή η συνάρτηση βάζει ένα νήμα σε κατάσταση αναμονής μέχρι η τιμή της μεταβλητής `var` να οριστεί σε false (ή μηδέν, ή οτιδήποτε επιστρέφει false).
6. `waitonjoined()`: Αυτή η συνάρτηση περιμένει τα νήματα που ξεκίνησαν εντός του τρέχοντος νήματος να τερματίσουν. Αυτά τα νήματα πρέπει να έχουν δηλωθεί με τη σημαία `join`.
7. `wait(string)`: Αυτή η συνάρτηση βάζει ένα νήμα σε κατάσταση αναμονής χρησιμοποιώντας ένα string ως ενεργοποιητή. Η κατάσταση αναμονής απελευθερώνεται όταν γίνεται μια `cast` σε αυτό το string.

### Παράδειγμα 1

```java
// Χρησιμοποιούμε το string "test" ως ενεργοποιητή
joined thread waiting() {
    wait("test");
    println("Απελευθερώθηκε");
}

// Κάνουμε κάποιες εργασίες και στη συνέχεια απελευθερώνουμε το νήμα που περιμένει
joined thread counting() {
    int nb = 0;
    while (nb < 10000)
        nb++;
    cast("test");
    println("Τέλος μέτρησης");
}

waiting();
counting();
waitonjoined();
println("Τέλος");
```

Εκτέλεση:

Εάν εκτελέσουμε το πρόγραμμα παραπάνω, το Tamgu θα εμφανίσει με την ακόλουθη σειρά:

```
Τέλος μέτρησης
Απελευθερώθηκε
Τέλος
```

### Παράδειγμα 2

```java
int nb = 1000;

joined thread decompte() {
    while (nb > 1) {
        nb--;
    }
    printlnerr("Τέλος μέτρησης", nb);
    nb--;
}

joined thread attend() {
    waitonfalse(nb);
    printlnerr("Οκ");
}

attend();
decompte();
waitonjoined();
printlnerr("Τέλος");
```

### Mutex: lock και unlock

Υπάρχουν περιπτώσεις όπου είναι απαραίτητο να αποτραπεί η πρόσβαση ορισμένων νημάτων στις ίδιες γραμμές ταυτόχρονα, για παράδειγμα για να διασφαλιστεί ότι δύο κλήσεις συνάρτησης εφαρμόζονται πλήρως πριν ένα άλλο νήμα αναλάβει τον έλεγχο. Όταν ένα κλείδωμα ορίζεται σε μια συγκεκριμένη συνάρτηση, οι επόμενες γραμμές αυτής της συνάρτησης δεν είναι πλέον προσβάσιμες από άλλα νήματα μέχρι να κληθεί ένα ξεκλείδωμα.

Παράδειγμα:

```java
// Υλοποιούμε το νήμα μας
thread launch(string n, int m) {
    int i;
    println(n);
    // Εμφανίζουμε όλες τις τιμές μας
    for (i = 0; i < m; i++)
        print(i, " ");
    println();
}

function principal() {
    // Ξεκινάμε το νήμα μας
    launch("Πρώτο", 2);
    launch("Δεύτερο", 4);
}
```

Εάν το εκτελέσουμε, θα έχουμε ένα αρκετά τυχαίο αποτέλεσμα, καθώς τα νήματα εκτελούνται με μια ανεξάρτητη από τον πυρήνα τάξη.

```
Πρώτο
Δεύτερο
0 1
0 1 2 3
```

Αυτή η σειρά μπορεί να επιβληθεί με κλειδώματα, τα οποία θα εμποδίσουν τον πυρήνα από την εκτέλεση των ίδιων γραμμών ταυτόχρονα.

Πρέπει να προσθέσουμε κλειδώματα στον κώδικα για να αποτρέψουμε το σύστημα να συγχωνεύει γραμμές σε ένα αποτρόπαιο αποτέλεσμα:

```java
// Υλοποιούμε ξανά το νήμα μας με ένα κλείδωμα
thread launch(string n, int m) {
    lock("launch"); // Κλειδώνουμε εδώ, κανείς δεν μπορεί να περάσει πλέον
    int i;
    println(n);
    // Εμφανίζουμε όλες τις τιμές μας
    for (i = 0; i < m; i++)
        print(i, " ");
    println();
    unlock("launch"); // Ξεκλειδώνουμε με το ίδιο string, για να επιτρέψουμε την πέραση.
}
```

Στη συνέχεια, όταν εκτελέσουμε ξανά αυτό το κομμάτι κώδικα, θα έχουμε ένα εντελώς διαφορετικό αποτέλεσμα, που είναι πιο συμβατό με αυτό που αναμένουμε:

```
Πρώτο
0 1
Δεύτερο
0 1 2 3
```

Αυτή τη φορά οι γραμμές θα εμφανιστούν σύμφωνα με τη σειρά τους στον κώδικα.

Σημαντικό: Τα strings κλειδώματος είναι παγκόσμια για ολόκληρο τον κώδικα, πράγμα που σημαίνει ότι ένα κλείδωμα κάπου μπορεί να ξεκλειδώσει αλλού. Σημαίνει επίσης ότι ένα κλείδωμα σε ένα συγκεκριμένο string μπορεί να αποκλείσει άλλο μέρος του κώδικα που θα χρησιμοποιούσε το ίδιο string για να κλειδώσει τις γραμμές του. Συνίσταται, επομένως, να χρησιμοποιούνται πολύ συγκεκριμένα strings για να διαφοροποιηθεί ένα κλείδωμα από ένα άλλο.

### Προστατευμένα νήματα

Το παραπάνω παράδειγμα θα μπορούσε να ξαναγραφεί με ακριβώς την ίδια συμπεριφορά χρησιμοποιώντας μια προστατευμένη συνάρτηση.

```java
// Υλοποιούμε ξανά το νήμα μας ως προστατευμένη συνάρτηση
protected thread launch(string n, int m) {
    int i;
    println(n);
    // Εμφανίζουμε όλες τις τιμές μας
    for (i = 0; i < m; i++)
        print(i, " ");
    println();
}
```

Αυτή η συνάρτηση θα δώσει ακριβώς την ίδια έξοδο με την προηγούμενη. Τα προστατευμένα νήματα υλοποιούν ένα κλείδωμα στην αρχή της εκτέλεσης και το απελευθερώνουν όταν η συνάρτηση τερματίζεται. Ωστόσο, το πλεονέκτημα της χρήσης κλειδωμάτων έναντι μιας προστατευμένης συνάρτησης είναι η δυνατότητα να είμαστε πολύ πιο ακριβείς σχετικά με ποιες γραμμές πρέπει να προστατευθούν.

### Σημαφόροι: waitonfalse

Αν οι παραπάνω συναρτήσεις είναι χρήσιμες σε ένα πολυνηματικό πλαίσιο, δεν είναι αρκετές σε ορισμένες περιπτώσεις. Το Tamgu παρέχει συναρτήσεις που χρησιμοποιούνται για να συγχρονίσουν νήματα με τιμές μεταβλητών. Αυτές οι συναρτήσεις μπορούν να συνδεθούν μόνο με απλούς τύπους, όπως Boolean, integer, float ή string.

Ο ρόλος αυτών των δύο συναρτήσεων είναι για ένα νήμα να περιμένει μέχρι μια συγκεκριμένη μεταβλητή να φτάσει σε τιμή false. Το false επιστρέφεται αυτόματα όταν μια αριθμητική μεταβλητή έχει την τιμή 0, όταν ένα string είναι άδειο ή όταν μια μεταβλητή Boolean έχει την τιμή false.

`waitonfalse(var)`: Αυτή η συνάρτηση θα βάλει ένα νήμα σε κατάσταση αναμονής μέχρι η μεταβλητή `var` να φτάσει την τιμή false.

Παράδειγμα:

```java
// Πρώτα, δηλώνουμε μια μεταβλητή stopby
// Σημαντικό: η αρχική της τιμή πρέπει να είναι διαφορετική από το 0
int stopby = 1;

// Υλοποιούμε το νήμα μας
thread launch(int m) {
    // Επαναφέρουμε το stopby με τον αριθμό των επαναλήψεων
    stopby = m;
    int i;
    // Εμφανίζουμε όλες τις τιμές μας
    for (i = 0; i < m; i++) {
        print(i, " ");
        // Μειώνουμε τη μεταβλητή stopby
        stopby--;
    }
}

function principal() {
    // Ξεκινάμε το νήμα μας
    launch(10);
    // Περιμένουμε το stopby να φτάσει το 0...
    waitonfalse(stopby);
    println("Τέλος");
}

principal();
```

Η εκτέλεση θα καθυστερήσει την εμφάνιση του "Τέλος" μέχρι να εμφανιστεί κάθε μεμονωμένο `i` στην οθόνη.

```
0 1 2 3 4 5 6 7 8 9 Τέλος
```

Εάν αφαιρέσουμε την `waitonfalse`, η έξοδος θα είναι αρκετά διαφορετική:

```
Τέλος 0 1 2 3 4 5 6 7 8 9
```

Όπως βλέπουμε σε αυτό το παράδειγμα, το Tamgu θα εμφανίσει πρώτα το μήνυμα "Τέλος" πριν εμφανίσει οποιεσδήποτε άλλες τιμές. Το `waitonfalse` συγχρονίζει το `principal` και το `launch` μαζί.

Σημείωση: Το παραπάνω παράδειγμα θα μπορούσε να εκτελεστεί με `wait` και `cast` ως εξής:

```java
// Υλοποιούμε ξανά το νήμα μας
thread launch(int m) {
    int i;
    // Εμφανίζουμε όλες τις τιμές μας
    for (i = 0; i < m; i++)
        print(i, " ");
    cast("end");
}

function principal() {
    // Ξεκινάμε το νήμα μας
    launch(10);
    wait("end");
    println("Τέλος");
}

principal();
```

Ωστόσο, πρέπει να θυμόμαστε ότι μόνο μια `cast` μπορεί να εκτελεστεί ταυτόχρονα για να απελευθερώσει νήματα. Με μια συγχρονισμένη μεταβλητή, το `waitonfalse` μπορεί να ενεργοποιηθεί από διάφορα νήματα, όχι μόνο από αυτό που θα εκτελούσε μια `cast`.

### `waitonjoined()` με τη σημαία `join`

Όταν ένα νήμα πρέπει να περιμένει να τελειώσουν άλλα νήματα πριν συνεχίσει, η απλούστερη λύση είναι να δηλώσουμε κάθε ένα από αυτά τα νήματα ως `join` και στη συνέχεια να χρησιμοποιήσουμε τη μέθοδο `waitonjoined()`.

Διάφορα νήματα μπορούν να περιμένουν σε διαφορετικά σύνολα joined νήματα ταυτόχρονα.

Παράδειγμα:

```java
// Ένα πρώτο νήμα με ένα join
join thread jdisplay(string s) {
    print(s + "\r");
}

// Το οποίο ξεκινά από αυτό το νήμα επίσης "join"
join thread launch(int x) {
    int i;
    for (i = 0; i < 5000; i++) {
        string s = "Thread:" + x + "=" + i;
        jdisplay(s);
    }
    // Περιμένουμε τα τοπικά μας νήματα να τελειώσουν
    waitonjoined();
    println("Τέλος:" + x);
}

// Ξεκινάμε δύο από αυτά
launch(0);
launch(1);
// Και περιμένουμε να τελειώσουν...
waitonjoined();
println("Τερματισμός");
```