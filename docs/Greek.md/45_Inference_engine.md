# Μηχανή Συλλογισμού

Το Tamgu ενσωματώνει μια μηχανή συλλογισμού, η οποία μπορεί να αναμιχθεί ελεύθερα με τις κανονικές οδηγίες του Tamgu. Αυτή η μηχανή συλλογισμού είναι πολύ παρόμοια με την Prolog, αλλά έχει κάποιες ιδιαιτερότητες:

α) Οι προθέσεις δεν χρειάζεται να δηλωθούν εκ των προτέρων για να διαχωρίσει το Tamgu τις προθέσεις από τις κανονικές συναρτήσεις. Ωστόσο, αν χρειάζεστε να χρησιμοποιήσετε μια πρόθεση που θα υλοποιηθεί αργότερα στον κώδικα, πρέπει να τη δηλώσετε εκ των προτέρων.

β) Δεν χρειάζεται να δηλώσετε μεταβλητές συλλογισμού. Ωστόσο, τα ονόματά τους είναι πολύ διαφορετικά από τα παραδοσιακά ονόματα της Prolog: πρέπει να προηγηθούν από ένα "?".

γ) Κάθε κλαυσίγελος τελειώνει με "." και όχι με ";".

δ) Οι όροι μπορούν να δηλωθούν εκ των προτέρων (ως μεταβλητές όρων). Ωστόσο, αν δεν θέλετε να τους δηλώσετε, πρέπει να προηγείται το όνομά τους με ένα "?" όπως για τις μεταβλητές συλλογισμού.

ε) Οι πιθανότητες μπορεί να επισυναφθούν σε προθέσεις, οι οποίες χρησιμοποιούνται για να επιλέξουν ως πρώτη διαδρομή αυτή με τις υψηλότερες πιθανότητες.

**Σημείωση**: Για μια αρκετή περιγραφή της γλώσσας Prolog, παρακαλούμε συμβουλευτείτε την κατάλληλη τεκμηρίωση.

## Τύποι

Το Tamgu αποκαλύπτει τρεις συγκεκριμένους τύπους για αντικείμενα συλλογισμού:

### Πρόθεση (Predicate)

Αυτός ο τύπος χρησιμοποιείται για να δηλώσει προθέσεις, οι οποίες θα χρησιμοποιηθούν σε κλαυσίγελους συλλογισμού. Αυτός ο τύπος αποκαλύπτει τις ακόλουθες μεθόδους:

1. `name()`: επιστρέφει την ετικέτα της πρόθεσης
2. `size()`: επιστρέφει τον αριθμό των ορισμάτων
3. `_trace(bool)`: ενεργοποιεί ή απενεργοποιεί το ίχνος για αυτήν την πρόθεση όταν είναι η κλήση πρόθεσης.

### Όρος (Term)

Αυτός ο τύπος χρησιμοποιείται για να δηλώσει όρους, οι οποίοι θα χρησιμοποιηθούν σε κλαυσίγελους συλλογισμούς (βλέπε το παράδειγμα NLP παρακάτω).

### Άλλοι Τύποι Συλλογισμού: Λίστα και Συσχετιστικός Χάρτης

Το Tamgu παρέχει επίσης τις παραδοσιακές λίστες, όπως στην Prolog, οι οποίες μπορούν να χρησιμοποιηθούν με τον τελεστή "|" για να χειριστούν την αποσύνθεση της λίστας (δείτε το παράδειγμα NLP παρακάτω για μια επίδειξη αυτού του τελεστή).

**Παράδειγμα:**

```tamgu
predicate alist;
// σε αυτόν τον κλαυσίγελο, το C είναι ο υπόλοιπος της λίστας...
alist([?A,?B|?C],[?A,?B],?C) :- true.
v=alist([1,2,3,4,5], ?X,?Y);
println(v); // [alist([1,2,3,4,5],[1,2],[3,4,5])]
```

Το Tamgu παρέχει επίσης ένα συσχετιστικό χάρτη, ο οποίος υλοποιείται ως ένας χάρτης Tamgu, αλλά στον οποίο η σειρά των ορισμάτων είναι σημαντική.

**Παράδειγμα:**

```tamgu
predicate assign,avalue;
avalue(1,1) :- true.
avalue(10,2) :- true.
avalue(100,3) :- true.
avalue("fin",4) :- true.
assign({?X:?Y,?Z:?V}) :- avalue(?X,1), avalue(?Y,2), avalue(?Z,3), avalue(?V,4).
vector v=assign(?X);
println(v); // [assign({'100':'fin','1':10})]
```

Όπως μπορείτε να δείτε σε αυτό το παράδειγμα, τόσο τα κλειδιά όσο και οι τιμές μπορούν να εξαρτώνται από μεταβλητές συλλογισμού. Ωστόσο, η σειρά με την οποία αυτά τα κλειδιά και οι τιμές συνδέονται είναι σημαντική. Έτσι, {?X:?Y,?Z:?V} είναι διαφορετικό από {?Z:?V,?X:?Y}.

### ΠρόθεσηVar (PredicateVar)

Αυτός ο τύπος χρησιμοποιείται για να χειριστεί προθέσεις για να εξερευνήσει τα ονόματα και τις τιμές τους. Ένα PredicateVar μπορεί να θεωρηθεί ως μια συνάρτηση, των οποίων τα παράμετροι είναι προσβάσιμες μέσω της θέσης τους στη λίστα ορισμάτων ως ένα vector. Αυτός ο τύπος αποκαλύπτει τις ακόλουθες μεθόδους:

1. `map()`: επιστρέφει την πρόθεση ως έναν χάρτη: [name:name,'0':arg0,'1':arg1,...]
2. `name()`: επιστρέφει το όνομα της πρόθεσης
3. `query(predicate|name,v1,v2,v3)`: δημιουργεί και αξιολογεί μια πρόθεση επί της παραλλαγής
4. `remove()`: αφαιρεί την πρόθεση από τη μνήμη
5. `remove(db)`: αφαιρεί την πρόθεση από τη βάση δεδομένων db
6. `size()`: επιστρέφει τον αριθμό των ορισμάτων
7. `store()`: αποθηκεύει την πρόθεση στη μνήμη
8. `store(db)`: αποθηκεύει την τιμή της πρόθεσης στη βάση δεδομένων db
9. `vector()`: επιστρέφει την πρόθεση ως ένα vector: [name,arg0,arg1,...]

Πρέπει να σημειωθεί ότι η μέθοδος "predicate", η οποία υπάρχει τόσο για έναν χάρτη όσο και για ένα vector, μετατρέπει το περιεχόμενο ενός vector ή ενός χάρτη πίσω σε μια πρόθεση, εφόσον το περιεχόμενό τους μιμείται την έξοδο της πρόθεσης του vector() και του map().

**Παράδειγμα:**

```tamgu
vector v=['female','mary'];
predicatevar fem;
fem=v.predicate(); // μετατρέπουμε το vector μας σε μια πρόθεση
fem.store(); // το αποθηκεύουμε στη βάση γεγονότων
v=fem.query(female,?X); // Δημιουργούμε μια πρόθεση ερώτησης στην πορεία
v=fem.query(female,'mary'); // Δημιουργούμε μια πρόθεση ερώτησης με ένα string
```

## Κλαυσίγελοι

Ένας κλαυσίγελος καθορίζεται ως εξής:

```tamgu
predicate(arg1,arg2,...,argn) :- pred(arg...),pred(arg,...), etc. ;
```

Γεγονός σε μια βάση γνώσης. Ένα γεγονός μπορεί να δηλωθεί σε ένα πρόγραμμα με την ακόλουθη οδηγία:

```tamgu
predicate(val1,val2,...).
```

ή

```tamgu
predicate(val1,val2,...) :- true.
```

είναι πράγματι ισοδύναμες με την παραπάνω σύνταξη.

**loadfacts(pathname)**: φόρτωση μιας μεγάλης βάσης γνώσης

Αν έχετε ένα αρχείο που αποθηκεύει μια πολύ μεγάλη βάση γνώσης, που περιέχει μόνο γεγονότα, είναι πιο αποδοτικό να χρησιμοποιήσετε το `loadfacts` με το όνομα αρχείου για να επιταχύνετε τη φόρτωση. Αυτή η οδηγία πρέπει να τοποθετηθεί στην αρχή του αρχείου σας. Θα αρχίσει να φορτώνει κατά τη διάρκεια της συντακτικής ανάλυσης.

**Αποκλεισμός (Disjunction)**

Το Tamgu δέχεται επίσης αποκλεισμούς σε κλαυσίγελους με τον τελεστή ";", ο οποίος μπορεί να χρησιμοποιηθεί αντί για "," μεταξύ προθέσεων.

**Παράδειγμα:**

```tamgu
predicate mere,pere;
mere("jeanne","marie").
mere("jeanne","rolande").
pere("bertrand","marie").
pere("bertrand","rolande").
predicate parent;
// Στη συνέχεια δηλώνουμε τον κανόνα μας ως αποκλεισμό...
parent(?X,?Y) :- mere(?X,?Y);pere(?X,?Y).
parent._trace(true);
vector v=parent(?X,?Y);
println(v);
```

**Αποτέλεσμα:**

```
r:0=parent(?X,?Y) --> parent(?X6,?Y7)
e:0=parent(?X8,?Y9) --> mere(?X8,?Y9)
k:1=mere('jeanne','marie').
success:2=parent('jeanne','marie')
k:1=mere('jeanne','rolande').
success:2=parent('jeanne','rolande')
[parent('jeanne','marie'),parent('jeanne','rolande')]
```

**Αποκοπή (Cut), Αποτυχία (Fail) και Σταμάτημα (Stop)**

Το Tamgu παρέχει επίσης ένα αποκοπή, η οποία εκφράζεται με το κλασικό "!". Παρέχει επίσης τη λέξη-κλειδί fail, η οποία μπορεί να χρησιμοποιηθεί για να εξαναγκάσει την αποτυχία ενός κλαυσίγελου. Το stop σταματά ολόκληρη την αξιολόγηση.

**Συναρτήσεις (Functions)**

Το Tamgu παρέχει επίσης μερικές κανονικές συναρτήσεις από τη γλώσσα Prolog, όπως:

**Συνάρτηση asserta(pred(...))**

Αυτή η συνάρτηση δηλώνει (εισάγει) μια πρόθεση στην αρχή της βάσης γνώσης. Να σημειωθεί ότι αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί μόνο μέσα σε μια δήλωση κλαυσίγελου.

**assertz(pred(...))**

Αυτή η συνάρτηση δηλώνει (εισάγει) μια πρόθεση στο τέλος της βάσης γνώσης. Να σημειωθεί ότι αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί μόνο μέσα σε μια δήλωση κλαυσίγελου.

**retract(pred(...))**

Αυτή η συνάρτηση αφαιρεί μια πρόθεση από τη βάση γνώσης. Να σημειωθεί ότι αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί μόνο μέσα σε μια δήλωση κλαυσίγελου.

**retractall(pred)**

Αυτή η συνάρτηση αφαιρεί όλες τις προθέσεις μιας πρόθεσης από τη βάση γνώσης. Αν η retractall χρησιμοποιηθεί χωρίς κανένα παράμετρο, τότε καθαρίζει όλη τη βάση γνώσης. Να σημειωθεί ότι αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί μόνο μέσα σε μια δήλωση κλαυσίγελου.

**Συνάρτηση: predicatedump(pred) ή findall(pred)**

Αυτή η συνάρτηση, όταν χρησιμοποιείται χωρίς κανένα παράμετρο, επιστρέφει όλες τις προθέσεις που είναι αποθηκευμένες στη μνήμη ως ένα vector. Εάν παρέχετε το όνομα μιας πρόθεσης ως ένα string, τότε εμφανίζει ως ένα vector όλες τις προθέσεις με το συγκεκριμένο όνομα.

**Παράδειγμα:**

```tamgu
// Σημειώστε ότι πρέπει να δηλώσετε "parent" αν θέλετε να το χρησιμοποιήσετε σε μια assert
predicate parent;
adding(?X,?Y) :- asserta(parent(?X,?Y)).
adding("Pierre","Roland");
println(predicatedump(parent));
```

**Παγκόσμιο Όνομα Πρόθεσης**

Όταν αναζητάτε γεγονότα σε μια βάση γνώσης, είναι δυνατόν να ερωτήσετε χωρίς ένα συγκεκριμένο όνομα πρόθεσης. Σε αυτήν την περίπτωση, μπορείτε να χρησιμοποιήσετε: "_" αντί για το όνομα της πρόθεσης.

**Παράδειγμα:**

```tamgu
// Η βάση γνώσης μας
father("george","sam").
father("george","andy").
mother("andy","mary").
mother("sam","christine").
// Ο κανόνας μας, θα ταιριάξει με οποιαδήποτε γεγονότα παραπάνω
parent(?A,?B) :- _(?A,?B).
```

Μπορούμε επίσης να χρησιμοποιήσουμε μερικές συγκεκριμένες μεταβλητές: _0.._9, οι οποίες μπορούν να επιστρέψουν ποιο όνομα πρόθεσης ταιριάχθηκε.

**Παράδειγμα:**

```tamgu
// Ο κανόνας μας, θα ταιριάξει με οποιαδήποτε γεγονότα παραπάνω
parent(?A,?B,?P) :- _1(?A,?B), ?P is _1.
```

Αυτός ο κώδικας επιστρέφει:

```
parent("andy","mary","mother")
parent("sam","christine","mother")
parent("george","sam","father")
parent("george","andy","father")
```

**Ουρητήριο Αναδρομής (Tail Recursion)**

Το ουρητήριο αναδρομής είναι ένας μηχανισμός που μετατρέπει μια αναδρομή σε μια επαναληπτική διαδικασία. Για να ενεργοποιήσετε τον μηχανισμό ουρητηρίου αναδρομής, πρέπει να τροποποιήσετε το όνομα του τελευταίου στοιχείου του κανόνα προσθέτοντας ένα "#". Το ουρητήριο αναδρομής ενεργοποιείται αν αυτό το τελευταίο στοιχείο αντιστοιχεί στον τρέχοντα κανόνα.

Η ουρητηρίωση μετατρέπει τη διάσχιση ενός vector, για παράδειγμα, σε μια επαναληπτική διαδικασία. Ωστόσο, στο τέλος της διαδικασίας, η αρχική τιμή του vector χάνεται.

**Παράδειγμα:**

```tamgu
vector v = [1..10];
// Τέλος της αναδρομής
traverse([],0).
// Το τελευταίο στοιχείο επισημαίνεται για ουρητήριο αναδρομής
traverse([?X|?Y],?A) :- println(?X,?Y), traverse#(?Y,?A).
vector vv = traverse(v,?A);
println(vv);
```

**Αποτέλεσμα:**

```
1 [2,3,4,5,6,7,8,9,10]
2 [3,4,5,6,7,8,9,10]
3 [4,5,6,7,8,9,10]
4 [5,6,7,8,9,10]
5 [6,7,8,9,10]
6 [7,8,9,10]
7 [8,9,10]
8 [9,10]
9 [10]
10 [] // Το πρώτο όρισμα είναι τώρα []
[traverse([],0)]
```

**Συνάρτηση Κλήσης Πίσω (Callback Function)**

Μια πρόθεση μπορεί να δηλωθεί με μια συνάρτηση κλήσης πίσω, η οποία έχει την ακόλουθη υπογραφή:

```tamgu
function OnSuccess(predicatevar p, string s) {
    println(s,p);
    return true;
}
```

Το δεύτερο όρισμα στη συνάρτηση αντιστοιχεί στην παράμετρο που δόθηκε στον κύριο κανόνα. Εάν η συνάρτηση επιστρέψει true, τότε η μηχανή συλλογισμού προσπαθεί άλλες λύσεις. Διαφορετικά, σταματά.

**Αποτέλεσμα:**

Εάν εκτελέσουμε το παραπάνω παράδειγμα, λαμβάνουμε:

```
Parent: parent('John','Mary')
Parent: parent('John','Peter')
```

**DCG**

Το Tamgu δέχεται επίσης κανόνες DCG (Definite Clause Grammar) με μερικές τροποποιήσεις στον αρχικό ορισμό. Πρώτον, οι μεταβλητές Prolog πρέπει να υποδηλώνονται με το "?V" όπως και στους άλλους κανόνες. Τρίτον, οι ατομικοί όροι μπορούν να δηλωθούν μόνο ως συμβολοσειρές.

**Παράδειγμα:**

```tamgu
predicate sentence,noun_phrase,det,noun,verb_phrase,verb;
term s,np,vp,d,n,v;
sentence(s(np(d("the"),n("cat")),vp(v("eats"),np(d("a"),n("bat"))))) --> [].
```

**Εκτέλεση Αξιολόγησης**

Οι αξιολογήσεις ξεκινούν ακριβώς με τον ίδιο τρόπο με ένα κανονικό συνάρτησης. Μπορείτε φυσικά να παρέχετε όσες μεταβλητές συλλογισμού θέλετε, αλλά μπορείτε να εκτελέσετε μόνο μια πρόθεση κάθε φορά, πράγμα που επιβάλλει το γεγονός ότι η έκφρασή σας πρέπει πρώτα να δηλωθεί ως κλαυσίγελος αν θέλετε να περιλαμβάνει περισσότερες από μία προθέσεις.

**Σημαντικό**: Εάν η μεταβλητή παραλήπτη είναι ένα vector, τότε θα παρέχονται όλες οι δυνατές αναλύσεις. Το δέντρο αξιολόγησης θα διασχίσει πλήρως. Εάν η μεταβλητή παραλήπτη είναι οτιδήποτε άλλο, τότε κάθε φορά που βρίσκεται μια λύση, η αξιολόγηση σταματά.

**Αντιστοίχιση Μεθόδων σε Προθέσεις**

Οι περισσότερες μεθόδοι αντικειμένων αντιστοιχούν σε προθέσεις με πολύ απλό τρόπο. Για παράδειγμα, αν ένα string εξάγει τη μέθοδο "trim", τότε ένα "p_trim" με δύο μεταβλητές δημιουργείται. Κάθε μέθοδος αντιστοιχεί σε μια πρόθεση με αυτόν τον τρόπο. Για κάθε μέθοδο, προσθέτουμε ένα πρόθεμα: "p_" για να μετατρέψουμε αυτήν τη μέθοδο σε μια πρόθεση. Το πρώτο όρισμα αυτής της πρόθεσης είναι το αντικείμενο κεφαλής της μεθόδου, ενώ η τελευταία παράμετρος είναι το αποτέλεσμα της εφαρμογής αυτής της μεθόδου σε αυτό το αντικείμενο. Έτσι, αν s είναι ένα string, s.trim() γίνεται p_trim(s,?X), όπου ?X είναι το αποτέλεσμα της εφαρμογής του trim στο s. Εάν είναι ενωμένο, τότε η πρόθεση θα ελέγξει εάν ?X είναι το ίδιο με s.trim().

**Παράδειγμα:**

```tamgu
compute(?X,?Y) :- p_log(?X,?Y).
between(?X,?B,?E), succ(?X,?Y).
```

**Συνηθισμένα Λάθη με τις Μεταβλητές Tamgu**

Εάν χρησιμοποιείτε κοινές μεταβλητές σε προθέσεις, όπως string s, integer s ή οποιοδήποτε άλλο είδος μεταβλητής, πρέπει να θυμάστε ότι αυτές οι μεταβλητές χρησιμοποιούνται στις προθέσεις ως τιμές σύγκρισης. Ένα παράδειγμα μπορεί να διευκρινίσει λίγο το τι εννοούμε.

**Παράδειγμα 1**

```tamgu
string s="test";
string sx="other";
predicate comp;
comp._trace(true);
comp(s,3) :- println(s).
comp(sx,?X);
```

Εκτέλεση:

```
r:0=comp(s,3) --> comp(other,?X172) --> Fail
```

Αυτή η δήλωση απέτυχε επειδή τα s και sx έχουν διαφορετικές τιμές.

**Παράδειγμα 2**

```tamgu
string s="test"; // τώρα έχουν τις ίδιες τιμές
string sx="test";
predicate comp;
comp._trace(true);
comp(s,3) :- println(s).
comp(sx,?X);
```

Εκτέλεση:

```
r:0=comp(s,3) --> comp(test,?X173)
e:0=comp(test,3) --> println(s)test
success:1=comp('test',3)
```

Πρέπει να είστε προσεκτικοί όταν σχεδιάζετε τους κλαυσίγελους σας για να χρησιμοποιήσετε εξωτερικές μεταβλητές ως τιμές σύγκρισης και όχι ως ορισμός. Εάν θέλετε να περάσετε μια τιμή συμβολοσειράς στην πρόθεσή σας, τότε η θέση για αυτήν τη συμβολοσειρά πρέπει να είναι μια μεταβλητή πρόθεσης.

**Παράδειγμα 3**

```tamgu
string sx="test";
predicate comp;
comp._trace(true);
comp(?s,3) :- println(?s).
comp(sx,?X);
```

Εκτέλεση:

```
r:0=comp(?s,3) --> comp(test,?X176)
e:0=comp('test',3) --> println(?s177:test)test
success:1=comp('test',3)
```

**Παραδείγματα**

**Πύργος του Χάνοι**

Το παρακάτω πρόγραμμα λύνει το πρόβλημα του πύργου του Χάνοι για εσάς.

```tamgu
predicate move;
move(1,?X,?Y,_) :- println('Move the top disk from ',?X,' to ',?Y).
move(?N,?X,?Y,?Z) :- ?N>1, ?M is ?N-1, move(?M,?X,?Z,?Y), move(1,?X,?Y,_), move(?M,?Z,?Y,?X).
predicatevar res;
res=move(3,"left","right","centre");
println(res);
```

**Πρόγονος**

Με αυτό το πρόγραμμα, μπορείτε να βρείτε τον κοινό γυναικείο πρόγονο μεταξύ διαφορετικών οικογενειακών σχέσεων γονιών.

```tamgu
predicate ancestor,parent,male,female,test;
ancestor(?X,?X) :- true.
ancestor(?X,?Z) :- parent(?X,?Y),ancestor(?Y,?Z).
parent("george","sam") :- true.
parent("george","andy") :- true.
parent("andy","mary") :- true.
male("george") :- true.
male("sam") :- true.
male("andy") :- true.
female("mary") :- true.
test(?X,?Q) :- ancestor(?X,?Q), female(?Q).
test._trace(true);
vector v=test("george",?Z);
println(v);
```

**Ένα Παράδειγμα NLP**

Αυτό το παράδειγμα αντιστοιχεί στους κλαυσίγελους που έχουν δημιουργηθεί από την προηγούμενη DCG γραμματική.

```tamgu
predicate sentence,noun_phrase,det,noun,verb_phrase,verb;
term P,SN,SV,dét,nom,verbe;
sentence(?S1,?S3,P(?A,?B)) :- noun_phrase(?S1,?S2,?A), verb_phrase(?S2,?S3,?B).
noun_phrase(?S1,?S3,SN(?A,?B)) :- det(?S1,?S2,?A), noun(?S2,?S3,?B).
verb_phrase(?S1,?S3,SV(?A,?B)) :- verb(?S1,?S2,?A), noun_phrase(?S2,?S3,?B).
det(["the"|?X],?X,dét("the")) :- true.
det(["a"|?X],?X,dét("a")) :- true.
noun(["cat"|?X],?X,nom("cat")) :- true.
noun(["dog"|?X],?X,nom("dog")) :- true.
verb(["eats"|?X],?X,verbe("eats")) :- true.
vector v;
v=sentence(?X,[],?A);
println("All the sentences that can be generated:",v);
// αναλύουμε μια πρόταση
v=sentence(["the","dog","eats","a","bat"],[],?A);
println("The analysis:",v);
```

**Κινούμενος Πύργος του Χάνοι**

Ο παρακάτω κώδικας εμφανίζει μια κινούμενη εικόνα στην οποία οι δίσκοι μετακινούνται από μια στήλη σε μια άλλη. Συνδυάζει γραφικά και προθέσεις.

```tamgu
predicate move;
map columns={'left':[70,50,30],'centre':[],'right':[]};
function disk(window w,int x,int y,int sz,int position) {
    int start=x+100-sz;
    int level=y-50*position;
    w.rectanglefill(start,level,sz*2+20,30,FL_BLUE);
}
function displaying(window w,self o) {
    w.drawcolor(FL_BLACK);
    w.font(FL_HELVETICA,40);
    w.drawtext("Left",180,200);
    w.drawtext("Centre",460,200);
    w.drawtext("Right",760,200);
    w.rectanglefill(200,300,20,460,FL_BLACK);
    w.rectanglefill(100,740,220,20,FL_BLACK);
    w.rectanglefill(500,300,20,460,FL_BLACK);
    w.rectanglefill(400,740,220,20,FL_BLACK);
    w.rectanglefill(800,300,20,460,FL_BLACK);
    w.rectanglefill(700,740,220,20,FL_BLACK);
    vector left=columns['left'];
    vector centre=columns['centre'];
    vector right=columns['right'];
    int i;
    for (i=0;i<left;i++)
        disk(w,100,740,left[i],i+1);
    for (i=0;i<centre;i++)
        disk(w,400,740,centre[i],i+1);
    for (i=0;i<right;i++)
        disk(w,700,740,right[i],i+1);
}
window w with displaying;
function moving(string x,string y) {
    columns[y].push(columns[x][-1]);
    columns[x].pop();
    w.redraw();
    pause(0.5);
    return true;
}
move(1,?X,?Y,_) :- moving(?X,?Y).
move(?N,?X,?Y,?Z) :- ?N>1, ?M is ?N-1, move(?M,?X,?Z,?Y), move(1,?X,?Y,_), move(?M,?Z,?Y,?X).
thread hanoi() {
    move(3,"left","right","centre");
}
function launch(button b,self o) {
    hanoi();
}
button b with launch;
w.begin(50,50,1000,800,"HANOI");
b.create(20,20,60,30,FL_Regular,FL_NORMAL_BUTTON,"Launch");
w.end();
w.run();
```