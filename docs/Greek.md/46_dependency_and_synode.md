# Εξάρτηση και Συνοδός

Οι εξαρτήσεις είναι ένα θεμελιώδες γλωσσικό αντικείμενο που έχει γίνει απαραίτητο στη σύγχρονη Επεξεργασία Φυσικής Γλώσσας. Το Tamgu προσφέρει μια συγκεκριμένη υλοποίηση αυτών των εξαρτήσεων με βάση τη μηχανή προκλήσεων. Ο στόχος αυτής της υλοποίησης είναι να πάρει την έξοδο ενός αναλυτή εξαρτήσεων (όπως ο αναλυτής του Stanford) ως είσοδο και να πραγματοποιήσει περαιτέρω ανάλυση πάνω της.

Οι εξαρτήσεις αξιολογούνται ως προκλήσεις που συνδέουν συντακτικούς κόμβους. Το σύστημά μας παρέχει έναν δεύτερο τύπο που ονομάζεται συνοδός, ο οποίος αντιπροσωπεύει έναν κόμβο σε ένα δένδρο συνιστωσών.

## Συνοδός

Μια συνοδός είναι ένας συντακτικός κόμβος που καθορίζεται από ένα σύνολο χαρακτηριστικών (υλοποιημένο ως ένας χάρτης) και τη θέση του στο δένδρο συνιστωσών. Μια συνοδός έχει τις ακόλουθες μεθόδους:

1. _initial(map m): Δημιουργεί ένα συντακτικό κόμβο με τα δοθέντα χαρακτηριστικά.
2. addchild(synode): Προσθέτει έναν κόμβο παιδί.
3. addnext(synode): Προσθέτει έναν επόμενο κόμβο.
4. addprevious(synode): Προσθέτει έναν προηγούμενο κόμβο.
5. after(synode): Επιστρέφει true εάν ο κόμβος είναι μετά τον δοθέντα κόμβο υπό τον ίδιο γονέα.
6. attributes(): Επιστρέφει τα χαρακτηριστικά των χαρακτηριστικών ως ένα διάνυσμα.
7. before(synode): Επιστρέφει true εάν ο κόμβος είναι πριν τον δοθέντα κόμβο υπό τον ίδιο γονέα.
8. child(): Επιστρέφει τον πρώτο κόμβο παιδί ή ελέγχει αν ταιριάζει με την παράμετρο.
9. children(): Επιστρέφει τη λίστα των παιδιών για έναν δοθέντα κόμβο ή ελέγχει αν ο κόμβος είναι παιδί.
10. definitions(mapss): Ορίζει τις έγκυρες ορισμούς χαρακτηριστικών για όλες τις συνοδούς.
11. last(): Επιστρέφει τον τελευταίο κόμβο παιδί ή ελέγχει αν ταιριάζει με την παράμετρο.
12. nbchildren(): Επιστρέφει τον αριθμό των άμεσων παιδιών.
13. next(synode): Επιστρέφει τον επόμενο κόμβο ή ελέγχει αν ταιριάζει με την παράμετρο.
14. parent(): Επιστρέφει τον γονικό κόμβο ή ελέγχει αν ταιριάζει με την παράμετρο.
15. previous(synode): Επιστρέφει τον προηγούμενο κόμβο ή ελέγχει αν ταιριάζει με την παράμετρο.
16. precede(synode): Επιστρέφει true εάν ο κόμβος είναι πριν (οπουδήποτε στο δένδρο).
17. sibling(synode): Ελέγχει αν ο κόμβος είναι αδελφός (είτε αδελφή είτε απόγονος).
18. sisters(synode): Επιστρέφει τη λίστα των αδελφών κόμβων ή ελέγχει αν ο κόμβος είναι αδελφός κόμβος.
19. succeed(synode): Επιστρέφει true εάν ο κόμβος είναι μετά (οπουδήποτε στο δένδρο).
20. test(string attribute): Ελέγχει αν ένα χαρακτηριστικό είναι μέρος της δομής του χαρακτηριστικού.
21. values(): Επιστρέφει τις τιμές των χαρακτηριστικών ως ένα διάνυσμα.

## Δημιουργία Δένδρου Συνιστωσών

Ένα δένδρο συνιστωσών δημιουργείται από πάνω προς τα κάτω. Όταν χρησιμοποιείται η συνάρτηση `addchild`, προσθέτει έναν κόμβο παιδί κάτω από τον τρέχοντα κόμβο, και κάθε επόμενη κλήση αυτής της συνάρτησης προσθέτει ένα νέο παιδί μετά τον προηγούμενο κόμβο παιδί.

Παράδειγμα:

```cpp
// Δημιουργούμε τον κόμβο NP
synode np({"pos": "np"});

// Στη συνέχεια, τρεις λεκτικοί κόμβοι
synode det({"pos": "det", "surface": "το"});
synode adj({"pos": "adj", "surface": "μεγάλο"});
synode noun({"pos": "noun", "surface": "σκύλος"});

// Τους προσθέτουμε κάτω από τον NP, έναν μετά τον άλλο
np.addchild(det);
np.addchild(adj);
np.addchild(noun);

// Εμφανίζουμε τους κόμβους με εσοχή
function Display(synode x, int i) {
    if (x == null)
        return;
    string sp;
    sp.fill(i, " ");
    println(sp, x);
    Display(x.child(), i + 4);
    Display(x.next(), i);
}

Display(np, 0);
```

Αποτέλεσμα:
```
#0['pos': 'np']
    #0['pos': 'det', 'surface': 'το']
    #0['pos': 'adj', 'surface': 'μεγάλο']
    #0['pos': 'noun', 'surface': 'σκύλος']
```

Παρατηρήστε το `#0`, το οποίο υποδηλώνει ότι η συνοδός δεν είναι μια μεταβλητή εξάρτησης.

## Τύπος Εξάρτησης

Μια εξάρτηση είναι μια σχέση μεταξύ δύο συνόδων. Οι εξαρτήσεις μπορούν να δημιουργηθούν άμεσα χρησιμοποιώντας τον τύπο `dependency`, ο οποίος μπορεί στη συνέχεια να αποθηκευθεί στη βάση γνώσης με τη χρήση της `assertz`, ή με έναν κανόνα εξάρτησης. Μια εξάρτηση αποτελείται από ένα όνομα, ένα σύνολο χαρακτηριστικών και μια λίστα ορισμάτων.

Μεθόδοι:
1. _initial([όνομα, χαρακτηριστικά, όρισμα1, όρισμα2, ...]): Δημιουργεί μια εξάρτηση με ένα όνομα (συμβολοσειρά), ένα σύνολο χαρακτηριστικών (ένας χάρτης) και μια λίστα ορισμάτων, κάθε ένα από τύπο synode.
2. features(): Επιστρέφει τα χαρακτηριστικά της εξάρτησης.
3. name(): Επιστρέφει το όνομα της εξάρτησης.
4. rule(): Επιστρέφει το αναγνωριστικό κανόνα που δημιούργησε αυτήν την εξάρτηση.

Παράδειγμα:

```cpp
// Δημιουργούμε δύο λεκτικούς κόμβους
synode det({"pos": "det", "surface": "το"});
synode noun({"pos": "noun", "surface": "σκύλος"});

dependency d(["DET", {"direct": "+"}, det, noun]);

// Το προσθέτουμε στη βάση γνώσης
assertz(d);

println(d);
```

Αποτέλεσμα:
```
DET['direct': '+']({"pos": "det", "surface": "το"}, {"pos": "noun", "surface": "σκύλος"})
```

## Κανόνας Εξάρτησης

Ένας κανόνας εξάρτησης ακολουθεί το πρότυπο:

```
If ([^|~] dep[χαρακτηριστικά] (#x[χαρακτηριστικά], #y) and/or dep(#w, #z)...)
    depres(#n, #nn), ..., depres(#n, #nn) / ~ / #x[..], #x[..].
```

Σε αυτόν τον κανόνα, τα `x`, `y`, `w`, `z`, `n`, `nn` είναι ακέραιοι που αντιπροσωπεύουν αντικείμενα συνόδων. Ο κανόνας ταιριάζει τις εξαρτήσεις στη βάση γνώσης έναντι αυτών που αποθηκεύονται στον κανόνα. Εάν βρεθεί ένα ταίριασμα, δημιουργούνται νέες εξαρτήσεις χρησιμοποιώντας τις ίδιες μεταβλητές.

Ο κανόνας μπορεί να συνδυάσει κλήσεις συναρτήσεων και προκλήσεις με εξαρτήσεις. Το σύμβολο `^` υποδηλώνει ότι η εξάρτηση θα τροποποιηθεί. Μόνο μια εξάρτηση μπορεί να τροποποιηθεί τη φορά σε έναν κανόνα. Το σύμβολο `~` αντιπροσωπεύει την αρνηση. Εάν τοποθετηθεί πριν από μια εξάρτηση, σημαίνει ότι η εξάρτηση δεν πρέπει να υπάρχει στη βάση γνώσης.

Εάν η έξοδος του κανόνα αντικατασταθεί με `~`, ο κανόνας θα εφαρμοστεί, αλλά δεν θα δημιουργηθούν εξαρτήσεις.

Γεγονός:
Ο πιο απλός τρόπος για να προσθέσετε μια εξάρτηση στη βάση γνώσης είναι να την εισαγάγετε ως γεγονός:

```
dep[χαρακτηριστικά](#1, #2).
```

## Χαρακτηριστικά

Η δομή των χαρακτηριστικών σε έναν κανόνα εξάρτησης ακολουθεί συγκεκριμένους κανόνες:
- Οι εισαγωγικές γραμμές είναι προαιρετικές γύρω από τα χαρακτηριστικά και τις τιμές.
- Ο σύμβολος `+` είναι η προεπιλεγμένη τιμή για τα χαρακτηριστικά με μία τιμή.

Τελεστές:
- `χαρακτηριστικό`: Ελέγχει την ύπαρξη του χαρακτηριστικού.
- `χαρακτηριστικό: τιμή`: Συγκρίνει το χαρακτηριστικό με την τιμή.
- `χαρακτηριστικό: ~`: Το χαρακτηριστικό δεν πρέπει να έχει καμία τιμή.
- `χαρακτηριστικό ~: τιμή`: Το χαρακτηριστικό δεν πρέπει να έχει την καθορισμένη τιμή.
- `χαρακτηριστικό = τιμή`: Ορίζει το χαρακτηριστικό με την καθορισμένη τιμή.
- `χαρακτηριστικό = ~`: Αφαιρεί το χαρακτηριστικό από τη δομή των χαρακτηριστικών.
- `χαρακτηριστικό -: παράμετρος`: Συγκρίνει το χαρακτηριστικό με ένα TREG (Tamgu Regular Expression).
- `χαρακτηριστικό ~ -: παράμετρος`: Συγκρίνει το χαρακτηριστικό με ένα TREG, το οποίο πρέπει να αποτύχει.

Stop:
Η πρόκληση `stop` μπορεί να χρησιμοποιηθεί για να σταματήσει η αξιολόγηση μιας γραμματικής. Όταν η μηχανή αξιολόγησης συναντά αυτήν την πρόκληση, σταματά να αξιολογεί περαιτέρω τη γραμματική, παραλείποντας τους υπόλοιπους κανόνες.

```cpp
If (stop) ~.
```

_dependencies():
Αυτή η μέθοδος ενεργοποιεί μια ανάλυση εξάρτησης εφαρμόζοντας κανόνες στη βάση γνώσης.

_setvalidfeatures(mapss χαρακτηριστικά):
Αυτή η μέθοδος ορίζει περιορισμούς στα έγκυρα χαρακτηριστικά που μπορούν να χρησιμοποιηθούν για τις συνόδους και τις εξαρτήσεις. Τα χαρακτηριστικά καθορίζονται ως ζεύγη χαρακτηριστικών/τιμών σε έναν χάρτη. Εάν ένα χαρακτηριστικό μπορεί να έχει οποιαδήποτε τιμή, όπως το lemma ενός λέξης, η τιμή πρέπει να είναι μια κενή συμβολοσειρά. Η προεπιλεγμένη τιμή είναι `+`.

Παράδειγμα:

```cpp
mapss χαρακτηριστικά = {'Obl': '+', 'lemma': '', 'c_person': '+', 'CR4': '+', 'Punct': '+', 'surface': ''};
_setvalidfeatures(χαρακτηριστικά);
```

## Παράδειγμα

```cpp
// Εμφανίζουμε τους κόμβους με εσοχή
function Display(synode x, int i) {
    if (x == null)
        return;
    string sp;
    sp.fill(i, " ");
    println(sp, x);
    Display(x.child(), i + 5);
    if (i) // όταν i==0, είναι η ρίζα του δένδρου, δεν θέλουμε να εμφανίσουμε τις αδελφές του
        Display(x.next(), i);
}

// Προετοιμάζουμε το δένδρο συνιστωσών
synode np1 = {"bar": 2};
synode np2({"bar": 2});
synode vp({"bar": 2});
synode s({"bar": 3});
synode v({"word": "τρώει", "pers": 3, "pres": "+", "verb": "+"});
synode d1({"word": "το", "det": "+"});
synode n1({"word": "σκύλο", "noun": "+"});
synode d2({"word": "ένα", "det": "+"});
synode n2({"word": "κόκκαλο", "noun": "+"});

s.addchild(np1);
s.addchild(vp);
vp.addchild(v, np2);
np1.addchild(d1, n1);
np2.addchild(d2, n2);

// Είναι δυνατόν να προσθέσουμε ή να τροποποιήσουμε υπάρχοντα χαρακτηριστικά ως ένας χάρτης
vp["pos"] = "verb";
np1["pos"] = "noun";
np2["pos"] = "noun";

// Οι αρχικές μας εξαρτήσεις
subj(v, n1).
obj(v, n2).
det(n1, d1).
det(n2, d2);

// Μπορούμε επίσης να το δημιουργήσουμε με διαφορετικό τρόπο
dependency dpe(["mydep", {}, n1, n2]);

// Αλλά τότε πρέπει να το προσθέσουμε στη βάση γνώσης μόνοι μας
assertz(dpe);

// Αυτή η συνάρτηση καλείται από έναν κανόνα παρακάτω. Το #x γίνεται αντικείμενο synode.
// Η συνάρτηση επιστρέφει true για να αποφευχθεί η αποτυχία του κανόνα.
function DTree(synode n) {
    Display(n, 0);
    println("---------------------------");
    return true;
}

// Ένας απλός κανόνας που αντιστρέφει τους κόμβους
If (subj(#1, #2)) inverted(#2, #1).

// Ένας κανόνας που χρησιμοποιεί περιορισμούς στους κόμβους
If (subj(#1[pres, pers: 3], #2) and obj(#1, #3)) arguments(#2, #1, #3).

// Προσθέτουμε χαρακτηριστικά σε μια εξάρτηση
If (^subj(#1, #2)) subj[direct=+](#1, #2).

// Χρησιμοποιούμε _ για να περιηγηθούμε ανάμεσα σε όλες τις εξαρτήσεις με δύο ορίσματα, με περιορισμό ότι δύο κόμβοι είναι διαφορετικοί
If (_(#1, #2) && obj(#1, #3) && #2 != #3) link(#2, #3).

// Χρησιμοποιούμε μεταβλητές εξάρτησης _1 και _2 για να αποφύγουμε τη δημιουργία μιας εξάρτησης μεταξύ των ίδιων ορισμάτων
If (_1(#1, #2) && obj_2(#1, #3) && _1 != _2) other(#2, #3).

// Σημειώνουμε έναν κόμβο μέσω κανόνα εξάρτησης, και μπορούμε να χρησιμοποιήσουμε περιορισμούς και στη δομή επίσης
If (subj(#1, #2) and obj(#1, #3) and #2[noun:+, subject=+]) ~.

// Μπορούμε επίσης να γράψουμε αυτόν τον κανόνα χρησιμοποιώντας εισαγωγικά
If (subj(#1, #2) and obj(#1, #3) and #3["object"] = "+") ~.

// Σε αυτήν την περίπτωση, έχουμε πρόσβαση στο γονέα του κόμβου #1 χρησιμοποιώντας την πρόκληση p_parent
// Στη συνέχεια καλούμε τη DTree για να το εμφανίσουμε... Η DTree πρέπει να επιστρέψει true, διαφορετικά ο κανόνας θα αποτύχει
// Το #3 μετατρέπεται αυτόματα σε αντικείμενο synode όταν καλείται η συνάρτηση
If (det(#1, #2) and p_parent(#1, #3) and DTree(#3)) ~.

// Χρησιμοποιούμε ένα TREG ως περιορισμό στον κανόνα μας
If (obj(#1[word -: "e%a+"], #2)) Verb(#1).

// Εκτελούμε τον αναλυτή εξάρτησης μας
_dependencies();

// Συλλέγουμε όλες τις εξαρτήσεις στη βάση γνώσης
vector res = predicatedump();

Display(s, 0);
println("---------------------------");
printjln(res);
```

Αποτέλεσμα:
```
s
#0['bar': '2', 'pos': 'noun']
    #0['word': 'το', 'det': '+']
    #0['word': 'σκύλο', 'noun': '+', 'subject': '+']
---------------------------
#0['bar': '2', 'pos': 'noun']
    #0['word': 'ένα', 'det': '+']
    #0['object': '+', 'word': 'κόκκαλο', 'noun': '+']
---------------------------
#0['bar': '3']
#0['bar': '2', 'pos': 'noun']
    #0['word': 'το', 'det': '+']
    #0['word': 'σκύλο', 'noun': '+', 'subject': '+']
#0['bar': '2', 'pos': 'verb']
    #0['word': 'τρώει', 'pers': '3', 'pres': '+', 'verb': '+']
#0['bar': '2', 'pos': 'noun']
    #0['word': 'ένα', 'det': '+']
    #0['object': '+', 'word': 'κόκκαλο', 'noun': '+']
---------------------------
other({"word": "σκύλο", "noun": "+", "subject": "+"}, {"object": "+", "word": "κόκκαλο", "noun": "+"})
subj['direct': '+']({"word": "τρώει", "pers": "3", "pres": "+", "verb": "+"}, {"word": "σκύλο", "noun": "+", "subject": "+"})
inverted({"word": "σκύλο", "noun": "+", "subject": "+"}, {"word": "τρώει", "pers": "3", "pres": "+", "verb": "+"})
obj({"word": "τρώει", "pers": "3", "pres": "+", "verb": "+"}, {"object": "+", "word": "κόκκαλο", "noun": "+"})
det({"word": "σκύλο", "noun": "+", "subject": "+"}, {"word": "το", "det": "+"})
det({"object": "+", "word": "κόκκαλο", "noun": "+"}, {"word": "ένα", "det": "+"})
arguments({"word": "σκύλο", "noun": "+", "subject": "+"}, {"word": "τρώει", "pers": "3", "pres": "+", "verb": "+"}, {"object": "+", "word": "κόκκαλο", "noun": "+"})
link({"word": "σκύλο", "noun": "+", "subject": "+"}, {"object": "+", "word": "κόκκαλο", "noun": "+"})
Verb({"word": "τρώει", "pers": "3", "pres": "+", "verb": "+"})
```