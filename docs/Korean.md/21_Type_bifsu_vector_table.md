## Tamgu 벡터 및 테이블 컨테이너

### 벡터 컨테이너
Tamgu는 다양한 유형의 데이터에 대한 특수화된 벡터 컨테이너를 제공합니다. 이러한 컨테이너는 메모리 소비에 효율적이며 요소에 빠른 액세스를 제공합니다. 다음은 사용 가능한 벡터 유형입니다:

- **bvector**: 바이트를 위한 벡터 컨테이너입니다.
- **ivector**: 정수를 위한 벡터 컨테이너입니다.
- **lvector**: long 형을 위한 벡터 컨테이너입니다.
- **fvector**: 부동 소수점 수를 위한 벡터 컨테이너입니다.
- **svector**: 문자열을 위한 벡터 컨테이너입니다.
- **uvector**: 유니코드 문자열을 위한 벡터 컨테이너입니다.

이러한 컨테이너는 해당 유형의 값만 저장할 수 있습니다. 문자열을 벡터에 저장할 때 Tamgu는 벡터 내에 저장될 특정 문자열 객체를 생성해야 합니다. 그러나 svector의 경우 문자열이 특정 문자열 객체 없이 직접 저장됩니다. 이는 저장 공간을 문자열에만 사용하고 액세스 속도를 향상시킵니다.

이러한 구조체를 사용하려면 일반적인 벡터와 마찬가지로 다룰 수 있습니다. 예를 들어:

```cpp
svector test;
test.push("toto");
```

### 테이블 컨테이너
"테이블"은 Tamgu에서 제공하는 다른 컨테이너입니다. 이는 정수를 인덱스로 사용하는 고정 크기 컨테이너입니다. 테이블의 크기는 생성 시 정의되어야 하며 이후에 변경할 수 없습니다. 테이블 컨테이너는 C 테이블 구현을 기반으로 하여 매우 빠릅니다.

특정 크기로 테이블을 생성하고 해당 요소에 액세스하려면 다음과 같이 할 수 있습니다:

```cpp
table test(10);
test[1] = "i";
```

테이블의 초기 크기가 너무 작은 경우 "resize" 메서드를 사용하여 크기를 확장하거나 줄일 수 있습니다. 이 메서드는 테이블의 현재 크기를 수정하고 모든 이전 요소를 새 위치로 복사합니다. 그러나 테이블의 크기를 줄이면 새 제한을 넘는 요소는 손실됩니다.

```cpp
table test(10);
println(test.size()); // 출력: 10
test.resize(20);
println(test.size()); // 출력: 20
```

테이블 컨테이너는 스레드에서 동시에 읽기/쓰기 작업을 보호하지 않습니다. 동일한 요소에 대해 동시에 읽기/쓰기가 발생하지 않음을 보장할 수 있다면, 내부 잠금의 수를 줄이기 때문에 이 구조체를 사용하는 것이 매우 효율적일 수 있습니다. 그러나 충돌 가능성이 있는 경우 충돌을 피하기 위해 잠금을 사용하는 것이 안전합니다.

또한, Tamgu는 요소에 대한 동시 액세스가 방해될 수 있기 때문에 스레드 내에서 크기 조정을 방지합니다.