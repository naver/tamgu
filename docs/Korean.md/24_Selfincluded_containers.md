# 자체 포함 컨테이너

탐구에서는 값 컨테이너와 객체 컨테이너 두 가지 종류의 컨테이너가 있습니다.

## 값 컨테이너
값 컨테이너에는 svector, ivector 및 mapii가 포함됩니다. 이러한 컨테이너는 값을 보관합니다.

## 객체 컨테이너
객체 컨테이너에는 vector, map, treemap, table 및 list가 포함됩니다. 이러한 컨테이너는 객체를 보관합니다.

## 객체 컨테이너에서의 루프
컨테이너 내부에 다른 컨테이너를 포함시키는 것은 가능하지만, 컨테이너 자체를 포함하는 경우 전체 구조를 표시할 수 없습니다. 대신 시스템은 자기 참조를 "[...]" 또는 맵인 경우 "{...}"로 대체합니다.

예시:

```cpp
vector v = [1..5];
v.push(v);
println(v);
```

출력: `v is: [1,2,3,4,5,[...]]`, "[...]"는 자기 참조를 나타냅니다.

자체를 포함하는 컨테이너가 있는 경우 구조를 탐색하는 데 문제가 발생할 수 있으므로 주의해야 합니다. 이는 무한 루프를 초래할 수 있습니다.

## 메서드 표시
탐구는 이러한 문제를 해결하기 위해 세 가지 메서드를 제공합니다:

a) `mark(byte v)`: 이 메서드는 객체 컨테이너에 표시를 추가합니다.

b) `mark()`: 이 메서드는 객체 컨테이너의 표시를 반환합니다.

c) `unmark()`: 이 메서드는 객체 컨테이너 내의 모든 표시를 제거합니다.

예시:

```cpp
vector v = [10..50:10];
v.push([60..80:10]);
v.push(v);
println(v);

function traversal(self v, int i) {
  if (i == v.size()) {
    println('벡터의 끝');
    return;
  }
  if (v[i].mark() == 1) {
    println("이미 분석됨");
    return;
  }
  println(i, v[i]);
  v[i].mark(1);
  if (v[i].iscontainer()) {
    println("이 값은 컨테이너입니다...");
    traversal(v[i], 0);
  }
  traversal(v, i + 1);
}

// 벡터를 두 번 탐색하지 않기 위해 벡터에 표시를 추가합니다.
v.mark(1);
traversal(v, 0);

// 한 번에 모든 요소의 표시를 제거합니다.
v.unmark();

// 출력:
// [10,20,30,40,50,[60,70,80],[...]], 자체 참조를 포함합니다
// 실행 결과
// 0 10
// 1 20
// 2 30
// 3 40
// 4 50
// 5 [60,70,80]
// 이 값은 컨테이너입니다...
// 0 60
// 1 70
// 2 80
// 벡터의 끝
// 이미 분석됨
// 종료
```