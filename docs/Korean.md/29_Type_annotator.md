# 어노테이터

## 설명

`어노테이터`는 규칙 기반 텍스트 주석 도구입니다. 이 도구를 사용하여 텍스트에서 특정 패턴을 레이블링하는 규칙을 정의할 수 있습니다. 어노테이터 규칙은 렉시콘 규칙, 주석 규칙, 전역 규칙 및 삭제 규칙으로 구분됩니다.

## 규칙 구문

`어노테이터` 도구의 규칙은 토큰과 의미 범주를 결합한 정규 표현식입니다. 이 규칙은 일치하는 토큰의 범위와 관련된 레이블을 반환합니다.

규칙의 본문은 `<-` 또는 `←` 기호 뒤에 작성됩니다. 규칙에서 사용할 수 있는 연산자는 다음과 같습니다:

- `{t1,t2,t3...}`: 나열된 토큰 중 하나와 일치합니다.
- `?`: 모든 토큰과 일치합니다.
- `#label`: 규칙이나 렉시콘 레이블에서 생성된 의미 레이블과 일치합니다.
- `#{l1,l2...}`: 레이블이 나열된 레이블 중 하나와 일치합니다 (분리).
- `#[l1,l2...]`: 레이블이 나열된 모든 레이블과 일치합니다 (결합).
- `*`, `+ (:c)`: 카운터와 함께 사용할 수 있는 Kleene 연산자입니다.
- `~`: 부정 (원자 요소에만 해당).
- `(...)`: 선택적인 토큰 시퀀스입니다.
- `[...]`: 토큰 시퀀스입니다.
- `>..<`: 최종 주석에서 이 시퀀스의 토큰을 건너뜁니다.
- `<call p1 p2>`: 참 또는 거짓을 반환하는 함수를 호출합니다.
- `token`: 단일 토큰과 일치합니다.
- `'rgx'`: POSIX 정규 표현식 구문을 기반으로 한 정규 표현식과 일치합니다.
- `"metas"`: 메타 문자를 기반으로 한 Tamgu 특정 정규 표현식과 일치합니다.

## 어노테이터 메서드

`어노테이터` 유형은 규칙에 의해 생성된 주석을 조사하기 위해 여러 메서드를 노출합니다:

- `compile(string rules)`: `rules` 문자열에 저장된 규칙을 `어노테이터` 변수로 컴파일합니다. 규칙에는 이 변수만 액세스할 수 있습니다.
- `select(uvector labels)`: `labels`에 정의된 레이블을 가진 규칙을 선택합니다.
- `clear()`: 레이블 선택을 지웁니다.
- `selection()`: 레이블 선택을 반환합니다.
- `lexicon(transducer t)`: 일반 목적의 변환기 렉시콘을 `어노테이터`에 연결합니다.
- `compilelexicons()`: 렉시콘을 사전 컴파일합니다. 파싱 전에 호출되지 않으면 첫 번째 파싱에서 컴파일되어 지연이 발생할 수 있습니다.
- `spans(bool)`: `true`인 경우 주석 클래스와 해당 오프셋을 모두 반환하고, `false`인 경우 주석 클래스만 반환합니다.
- `parse(ustring txt, bool keeplex)`: 규칙을 `ustring`에 적용합니다.
- `apply(uvector tokens, bool keeplex)`: 규칙을 토큰 벡터에 적용합니다.
- `apply(vector morphos, bool keeplex)`: 규칙을 형태소 분석된 토큰 벡터에 적용합니다.
- `apply(annotator a, bool keeplex)`: 이전 `어노테이터` 파싱 또는 적용으로 계산된 구조에 규칙을 적용합니다.

## 콜백 함수

`어노테이터` 객체에 콜백 함수를 연결할 수 있습니다. 이 콜백 함수는 구문 분석이 수행된 후 텍스트에 규칙을 적용하기 전에 호출됩니다. 콜백 함수는 다음과 같은 형식을 갖습니다:

```cpp
function catching(vector v, annotator a) {
    v = pos.tagger(v);
    return v;
}
```

`catching` 함수는 주석에 추가 분석을 추가하는 데 사용할 수 있습니다. 벡터 `v`는 하위 벡터의 목록이며, 각 하위 벡터에는 단어, 그의 원형형, 특징, 왼쪽 오프셋 및 오른쪽 오프셋이 포함됩니다. 함수는 동일한 구조를 가진 벡터를 반환해야 합니다.

## 렉시콘 규칙

렉시콘 규칙은 도메인 어휘를 설명하는 데 사용됩니다. 이 규칙은 단어를 특정 레이블과 연결합니다. 렉시콘 규칙은 단순한 단어 또는 다중 단어 표현일 수 있습니다. 다중 단어 표현은 Tamgu 정규 표현식을 사용하여 하나의 토큰으로만 인식될 수 있습니다.

## 주석 규칙

주석 규칙은 본문과 관련된 레이블입니다. 본문에는 선택적 요소, 요소의 분리, 정규 표현식, 건너뛰기된 단어 등이 포함될 수 있습니다. 이 규칙은 원래 텍스트의 오프셋에 대한 레이블 목록을 반환합니다.

## 전역 규칙

전역 규칙은 `#` 또는 `~`로 시작하며 주석 규칙과 유사합니다. 그러나 전역 규칙은 텍스트를 처리한 후에 텍스트를 따라 적용되지 않고 주석을 처리하기 위해 적용됩니다. 전역 규칙은 새 주석을 추가하거나 기존 주석을 제거할 수 있습니다.

## 예제

```cpp
// 렉시콘
@positive  ← great.
@positive  ← better.
@food  ← sushi.

// 주석 규칙
food ← (#positive), #food +.

// 어노테이터 생성
annotator r;

// 규칙 컴파일
r.compile("@positive  ← great.\n@positive  ← better.\n@food  ← sushi.\nfood ← (#positive), #food +.");

// 텍스트에 규칙 적용
ustring txt = "The sushi was great.";
r.parse(txt, true);
```

위의 예제에서는 `어노테이터`를 생성하고, 규칙을 컴파일한 다음 "The sushi was great."라는 텍스트에 규칙을 적용합니다. 결과 주석은 `어노테이터` 객체에 저장됩니다.