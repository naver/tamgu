# 함수형 언어: Lisp와 같이

탐구(Tamgu)는 원래 언어 정의와 매우 유사한 Lisp 인터프리터를 제공합니다. 다음과 같은 두 가지 중요한 예외 사항이 있습니다:

1. Lisp 표현은 역슬래시(\)로 시작해야 합니다.
2. 이 언어는 Lisp의 기본 함수와 연산자를 노출시키지만 Tamgu 개인 명령어의 사용도 허용합니다.

## 방법

Lisp 인터프리터는 'lisp'라는 새로운 유형을 노출시킵니다. 이 유형은 벡터의 변형입니다. 이 유형에는 다음과 같은 두 가지 메소드가 있습니다:

- `eval(string)`: 문자열을 Lisp 명령으로 평가하여 결과를 반환합니다.
- `load(filename)`: 파일을 로드하고 해당 내용을 평가합니다.

참고: 이 두 가지 명령에는 큰따옴표와 역슬래시가 필요하지 않습니다.

**중요**: 파일에서 "오버로드"된 Lisp의 큰따옴표와 역슬래시를 사용하지 않을 수 있습니다. 이를 위해 파일의 처음 두 문자가 `()`인 경우에 순수한 Lisp 모드가 트리거됩니다.

## 기본 Lisp 연산자

Tamgu의 Lisp 버전에서는 다음과 같은 함수를 노출시킵니다:

1. `apply`: 함수를 인수 목록에 적용합니다.
2. `and`: 부울 표현식에서 사용됩니다.
3. `append`: 목록을 연결합니다.
4. `atomp`: 요소가 원자인지 확인합니다.
5. `body`: 함수의 본문을 반환합니다.
6. `block`: 명령 블록을 사용합니다. 블록의 마지막 명령은 값을 반환합니다.
7. `or`: 부울 표현식입니다.
8. `xor`: 부울 표현식으로, 두 개의 인수만 가질 수 있습니다.
9. `break`: 반복문을 종료합니다.
10. `car`: 목록의 첫 번째 요소를 반환합니다.
11. `cdr`: 목록의 나머지를 반환합니다.
12. `cond`: 조건문입니다.
13. `cons`: 두 요소로 목록을 생성합니다.
14. `consp`: 요소가 목록인지 확인합니다.
15. `defun`: 함수를 정의합니다.
16. `_dropwhile`: 조건과 일치하지 않을 때까지 요소를 건너뜁니다.
17. `eq`: 두 원자를 비교합니다.
18. `eval`: 문자열이나 Lisp 표현식을 평가합니다.
19. `_filter`: 목록에 필터를 적용합니다.
20. `_foldl`, `_foldr`: 목록에 연산 또는 람다를 적용합니다.
21. `_foldl1`, `_foldr1`: 목록에 연산 또는 람다를 적용합니다.
22. `for`: 목록에서 반복합니다.
23. `if`: 조건을 테스트합니다.
24. `key`: 컨테이너에서 값을 반환하거나 설정합니다.
25. `keys`: 컨테이너에서 값을 범위로 반환합니다.
26. `label`: 표현식에 레이블을 연결합니다.
27. `lambda`: v1, v2에 적용되는 함수입니다.
28. `list`: 요소로 목록을 생성합니다.
29. `_map`: 목록에 연산을 적용합니다.
30. `negation`: 부울 표현식으로, 인수를 부정합니다.
31. `nullp`: 값이 null인지 확인합니다.
32. `numberp`: 값이 숫자인지 확인합니다.
33. `quote`: 표현식을 인용합니다.
34. `return`: 반복문에서 값을 반환합니다.
35. `_scanl`, `_scanr`: 목록에 연산을 적용합니다.
36. `_scanl1`, `_scanr1`: 목록에 연산을 적용합니다.
37. `self`: 람다에서 반복합니다.
38. `setq`: 변수를 생성하거나 수정합니다.
39. `_takewhile`: 조건과 일치할 때까지 요소를 저장합니다.
40. `while`: 반복합니다.
41. `zerop`: 값이 0인지 확인합니다.
42. `_zip`: 목록을 결합합니다.
43. `_zipwith`: 목록을 중간 연산 또는 람다와 함께 결합합니다.

## 예제

다음은 Tamgu Lisp 인터프리터를 사용하는 몇 가지 예제입니다:

```lisp
; 'apply' 예제
(setq f '+)
(apply f '(1 2 3 4))

; 'and' 예제
(and (> i 10) (< i 20))

; 'append' 예제
(append '(a b c) '(e f g))

; 'block' 예제
(block
  (print 'ok)
  (+ 10 20)
)

; 'while' 예제
(while (< i 10)
  (if (== i 5)
    (break)
  )
)

; 'car', 'cdr' 예제
(car '(a b c))
(cadr '((a b c d) ef))

; 'cond' 예제
(cond
  ((< o 10) (print o))
  ((> o 100) (print o))
)

; 'cons' 예제
(cons 'a '(b c))

; 함수 정의
(defun add (x y) (+ x y))
(add 10 20)

; '_filter' 예제
; COMPARATOR는 인용된 비교 또는 람다일 수 있습니다.
(vector v = [1..10])
(println (_filter '(< 3) v))
(println (_filter (lambda (x) (< x 3)) v))

; 'for' 루프 예제
(vector v = [1..10])
(for i v (print i))

; 'if' 예제
(if (== i 10)
  (print i)
  (+ i 1)
)

; 'key' 예제
(key m "test")

; 'lambda' 예제
(int j = ((lambda (x) (+ 1 x)) 2))

; 'list' 예제
(list 'a 'b '(c d))

; '_map' 예제
(vector v = [1..5])
(println (_map '* v))
(println (_map '( - 1) v))
(println (_map '(1 -) v))
(println (_map (lambda (x) (* x 2)) v))

; 람다에서 'self' 예제
(p = ((lambda (x) (if (< x 20) (self (+ x x)) x)) 1))

; '_dropwhile' 예제
(v = (_dropwhile '(< 10) '(1 2 3 4 10 20 30)))

; '_takewhile' 예제
(v = (_takewhile '(< 10) '(1 2 3 4 10 20 30)))

; '_foldl' 예제
(int res = (_foldl '+ 10 '(10 20 30)))

; '_scanl' 예제
(v = (_scanl 1 (lambda (acc x) (+ acc (* 2 x))) '(10 20 30)))

; '_zip' 예제
(v = (_zip '(10 20) '(11 21) '(12 22)))

; '_zipwith' 예제
(v = (_zipwith '+ '(10 20) '(11 21) '(12 22)))
(v = (_zipwith (lambda (x y z) (- x z (+ 1 y))) '(10 20) '(11 21) '(12 22)))
```

## 순수한 Lisp 모드

표현식 앞에 역슬래시(\)를 사용하는 제약 조건을 갖는다면 소스 코드에 손쉽게 Lisp 명령을 추가할 수 있습니다. 그러나 콘솔에서 실험을 하려는 경우에는 이러한 제약 조건이 언어 사용에 제약을 가할 수 있습니다. 이를 해결하기 위해 `lispmode(bool)`를 도입했습니다. 이 명령은 특정한 순수한 Lisp 모드를 트리거하며, 이 모드에서는 이러한 제약 조건이 필요하지 않습니다. 일반적인 인터프리터로 돌아가려면 `(lispmode false)`를 작성해야 합니다.

Linux와 Mac OS에서 Tamgu 쉘을 사용하는 경우 `tamgu –lisp`를 호출하여 이 모드를 트리거할 수 있습니다. 쉘 내에서도 `lispmode`를 사용하여 두 모드 간에 전환할 수 있습니다.

순수한 Lisp 모드를 트리거하는 마지막 방법은 파일의 처음 두 문자로 `()`을 추가하는 것입니다. 파일에 이러한 두 문자가 포함되어 있으면 인덴터는 중괄호와 유사한 표현식 구분자로 괄호를 고려할 수 있습니다.

예시:

```lisp
()
(defun test(x) (+ x x))
```