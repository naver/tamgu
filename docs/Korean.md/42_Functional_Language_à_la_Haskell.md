# Taskell

Taskell은 Haskell에서 영감을 받은 함수형 언어입니다. Haskell과 유사한 기능을 제공하지만, 일부 특정한 함수에 초점을 맞추고 있습니다. Taskell은 완전한 Haskell 컴파일러처럼 동작하지는 않지만, Haskell 언어의 몇 가지 흥미로운 측면을 포함하고 있습니다.

## 시작하기 전에: 새로운 연산자들

언어에 들어가기 전에, Taskell 세계를 풍부하게 하는 몇 가지 특정 연산자를 소개하겠습니다.

### 범위 선언: [a..b]

Haskell 언어와 호환하기 위해, Taskell은 ".." 연산자를 사용하여 요소의 범위를 선언하는 새로운 방법을 추가했습니다. 예를 들어, `[1..10]`은 벡터 `[1,2,3,4,5,6,7,8,9,10]`를 정의합니다.

### 스텝

기본적으로 스텝은 1이지만, 다른 스텝을 설정할 수도 있습니다. 표현식 끝에 ":"를 사용하여 스텝을 직접 정의할 수 있습니다. 예를 들어, `[1..10:2]`는 벡터 `[1,3,5,7,9]`를 정의합니다. 스텝은 정의에서 다음 요소를 제공함으로써도 설정할 수 있습니다. 예를 들어, `[1,3..10]`은 벡터 `[1,3,5,7,9]`를 정의합니다. 문자로도 동작합니다. 예를 들어, `[‘a’,’c’..’g’]`는 벡터 `['a','c','e','g']`를 정의합니다. 동일한 벡터는 `[‘a’..’g’:2]`로도 정의할 수 있습니다.

### 무한 범위

Taskell은 무한한 요소의 범위 개념을 제공합니다. 두 가지 경우가 있습니다: 집합의 첫 번째 요소를 무시하거나 마지막 요소를 무시할 수 있습니다. `[1..]`은 1부터 시작하여 무한한 벡터를 정의합니다: `[1,2,3,4…`. `[..1]`은 1부터 시작하여 무한한 벡터를 정의합니다: `[1,0,-1,-2,-3…`. 다른 스텝도 사용할 수 있습니다. `[1..:2]`는 1부터 시작하여 무한한 벡터를 정의합니다: `[1,3,5…`. `[..1:2]`는 1부터 시작하여 무한한 벡터를 정의합니다: `[1,-1,-3…`. `[1,3..]`는 1부터 시작하여 무한한 벡터를 정의합니다: `[1,3,5…`. `[..-1,1]`는 1부터 시작하여 무한한 벡터를 정의합니다: `[1,-1,-3…`.

### 세 개의 새로운 연산자: &&&, |||, 그리고 ::

이 세 가지 연산자는 리스트의 요소를 연결하거나 벡터에 요소를 추가하는 데 사용됩니다.

#### 병합: &&&

이 연산자는 다른 요소들을 하나의 벡터로 병합하는 데 사용됩니다. 요소 중 하나가 리스트가 아닌 경우, 해당 요소는 현재 리스트에 그대로 병합됩니다. 예를 들어, `vector v= 7 &&& 8 &&& [1,2]; println (v);`는 `[7,8,1,2]`를 결과로 출력합니다. 이 연산자는 Haskell의 "++"와 유사합니다. 이 연산자는 이미 Tamgu에서 정의되어 있었으므로 "&&&"로 수정되었습니다.

#### 결합: ||| (c1 ||| c2)

이 연산자는 컨테이너의 값과 다른 컨테이너 또는 문자열의 값을 결합합니다. 컨테이너가 값 컨테이너인 경우, "+" 연산자를 사용하여 c1의 값과 c2의 값을 추가하거나 연결합니다. 예를 들어, `vector v= [1,2,3]; vector vv = [4,5,6]; println (v ||| vv); //[1,4],[2,5],[3,6]`가 결과로 출력됩니다. 마찬가지로, `ivector iv= [1,2,3]; ivector ivv = [4,5,6]; println (iv ||| ivv); //[5,7,9]`가 결과로 출력됩니다. 동일한 작업을 문자열, 맵 또는 정수 값이 있는 맵에 대해서도 수행할 수 있습니다.

#### 추가: ::

이 연산자는 요소를 현재 벡터에 병합합니다. 예를 들어, `1::v`는 `[1,7,8,1,2]`를 결과로 출력하고, `v::12`는 `[1,7,8,1,2,12]`를 결과로 출력합니다.

## 기본 사항

### Taskell과 유사한 명령문 선언

Tamgu에서의 모든 Taskell 명령문은 "<..>" 사이에 선언되어야 합니다. 이는 내부적으로 Tamgu 컴파일러가 Taskell 공식을 감지하는 데 사용됩니다. 예를 들어, `vector v=<map (+1) [1..10]>;`은 벡터의 각 요소에 1을 더합니다.

### 가장 간단한 구조

Taskell 프로그램의 가장 간단한 구조는 `<1>`과 같이 값을 반환하는 것입니다.

또한 `<3+1>;`과 같은 계산식을 반환할 수도 있으며, 이 경우 시스템은 단일 원자값을 반환합니다.

### >, <, |, <<, 그리고 >>

이러한 연산자들은 Taskell 공식 내에서 사용될 때 문제를 일으킬 수 있습니다. 이는 Taskell 괄호의 열림 또는 닫힘을 컴파일러가 혼동할 수 있기 때문입니다. 이러한 문제를 피하기 위해 이러한 표현식을 괄호로 감싸야 합니다.

예를 들어, `<x | x < - [-5..5], (x > 0)>`는 `[1,2,3,4,5]`를 반환하고, `< (x << 1) | x <- [0..5]>`는 `[0,2,4,6,8,10]`을 반환합니다.

### 반복

Taskell 언어는 리스트를 표현하는 편리하고 효율적인 방법을 제공합니다. Tamgu에서는 이러한 리스트를 "벡터"로 구현하며, 이는 다른 구조체간에 교환될 수 있습니다.

가장 기본적인 Taskell 명령문은 다음과 같은 형태를 가지고 있습니다: `<x | x < - v, Boolean>`. 이는 다음 단계를 거쳐 결과로 리스트를 반환합니다:

1. 현재 결과 리스트에 x를 추가합니다.
2. v를 반복하여 x를 얻습니다. 이는 `x <- v`로 표기됩니다.
3. 생략 가능한 부울 제약 조건을 추가합니다.

표현식에서 반복이 발생하기 때문에 리스트를 반환하는 것입니다. 예를 들어, `<x | x < - [-5..5], x!=0>`는 `[-5,-4,-3,-2,-1,1,2,3,4,5]`를 반환합니다.