# 43 유형의 Fibre

Fibre는 가벼운 실행 스레드입니다. 스레드와 마찬가지로, Fibre는 동일한 주소 공간을 공유합니다. 그러나 Fibre는 협력적인 멀티태스킹을 사용하고 스레드는 선점적인 멀티태스킹을 사용합니다. 스레드는 종종 커널의 스레드 스케줄러에 의존하여 바쁜 스레드를 선점하고 다른 스레드를 계속 실행하는 반면, Fibre는 실행 중인 동안 다른 Fibre를 실행하기 위해 자신을 양보합니다.

Tamgu에서는 Fibre가 Taskell 함수 위에 구현되어 있습니다. 이러한 함수는 실제 양보 함수가 없기 때문에 Fibre로 실행되려면 반복문이 포함되어야 합니다.

`fibre` 유형은 다음의 메서드를 노출합니다:

1. `run()`: 기록된 Fibre를 실행합니다.
2. `block()`: Fibre는 링크된 체인에 저장되고 시작부터 끝까지 반복됩니다. 새로운 Fibre가 이 목록에 추가되면 새로운 종단 요소가 됩니다. `block()`은 현재 종단 요소를 반복 경계로 정의하는 데 사용됩니다. 새로운 Fibre는 여전히 추가될 수 있지만 `unblock()`이 호출될 때까지 실행되지 않습니다. `block()`이 다른 현재 종단 요소와 함께 호출되면 이전 경계는 이 새로운 종단 요소로 이동됩니다.
3. `unblock()`: 반복 제한을 해제합니다.

## Fibre 선언하기

Fibre를 선언하려면 먼저 Taskell 함수를 구현한 다음 이 Taskell 함수를 Fibre 변수에 저장해야 합니다.

```cpp
<Myfunc(a1, a2, ..., an) = ...>
fibre f = MyFunc;
```

새로운 Fibre를 기록하려면 간단히 일부 매개변수와 함께 호출하면 됩니다:

```cpp
f(p1, p2, ..., pn);
```

`MyFunc`에 반복문이 포함되어 있지 않으면 자동으로 실행됩니다. 출력을 저장해야 하는 경우 스트림 연산자를 사용할 수 있습니다.

```cpp
vector v;
v.push(ivector());
v[-1] <<< f(200, 210);
```

## Fibre 종료: `break` 또는 반복 종료

Fibre를 종료하는 두 가지 방법이 있습니다: 반복자가 끝에 도달하거나 `break` 명령이 호출됩니다.

```cpp
<Myfunc(x, y) : if (x == 10) break else (x + 1) ...>
```

## 스레드

Fibre는 스레드 내에서 실행될 수 있지만 한 번에 하나의 Fibre만 한 스레드에서 `run()` 메서드를 실행할 수 있습니다. 그러나 스레드는 문제없이 병렬로 새로운 Fibre를 기록할 수 있습니다.

## 예제

```cpp
vector v;
int i;

// 결과를 저장하기 위해 정수 벡터를 초기화합니다...
for (i in <3>)
    v.push(ivector());

//-----------------------------------------------------------------------
function compute(int i, int x, int y) {
    return i + x + y;
}

<myfiber(x, y) = compute(i, x, y) | i <- [x..y]>

// myfiber로 Fibre 변수를 초기화합니다.
fibre f = myfiber;

//-----------------------------------------------------------------------
// 기록은 스레드에서 수행됩니다...
joined thread recording(int i, int x, int y) {
    println("Fiber:", i);
    v[i] <<< f(x, y);
}

function running() {
    f.run();
}

//-----------------------------------------------------------------------
// Fibre는 스레드에서 시작됩니다...
int n;

for (i in <0, 60, 20>) {
    recording(n, i, i + 19);
    n++;
}

// 모든 Fibre의 기록을 기다립니다
waitonjoined();

//-----------------------------------------------------------------------
// 실행합니다...
running();

println(v);
```

**결과:**

```
Fiber: 0
Fiber: 2
Fiber: 1
[[19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38],
[79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98],
[139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158]]
```