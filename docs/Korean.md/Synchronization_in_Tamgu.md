# Tamgu에서의 동기화

Tamgu는 스레드를 대기 상태로 만드는 간단한 방법을 제공합니다. 이 과정은 구현하기 매우 쉽습니다. Tamgu는 이러한 목적을 위해 다양한 함수를 제공합니다:

## 1. 메소드

1. `cast(string)`: 지정된 문자열에서 대기 중인 모든 스레드의 실행을 해제합니다.
2. `cast()`: 문자열 상태에 관계없이 모든 스레드를 해제합니다.
3. `lock(string s)`: 코드 일부에 잠금을 설정하여 두 스레드가 동시에 동일한 줄에 액세스하는 것을 방지합니다.
4. `unlock(string s)`: 잠금을 해제하여 다른 스레드가 함수의 내용에 액세스할 수 있도록 합니다.
5. `waitonfalse(var)`: 변수 `var`의 값이 false(또는 0 또는 false를 반환하는 값)로 설정될 때까지 스레드를 대기 상태로 만듭니다.
6. `waitonjoined()`: 현재 스레드 내에서 시작된 스레드가 종료될 때까지 기다립니다. 이러한 스레드는 `join` 플래그로 선언되어야 합니다.
7. `wait(string)`: 지정된 문자열을 트리거로 사용하여 스레드를 대기 상태로 만듭니다. `cast`가 해당 문자열에 대해 수행되면 대기 모드가 해제됩니다.

**예시 1:**

```cpp
// "test"라는 문자열을 트리거로 사용합니다.
joined thread waiting() {
    wait("test");
    println("해제됨");
}

// 일부 작업을 수행한 다음 대기 중인 스레드를 해제합니다.
attend();
decompte();
waitonjoined();
printlnerr("종료");
```

## 2. Mutex: Lock과 Unlock

특정 스레드가 동시에 동일한 줄에 액세스하지 못하도록 막아야 하는 경우가 있습니다. 예를 들어, 다른 스레드가 제어를 가져가기 전에 두 함수 호출이 완전히 적용되도록 보장해야 하는 경우입니다. 함수 내에서 잠금을 설정하면 해당 함수의 다음 줄은 잠금이 해제될 때까지 다른 스레드에게 접근할 수 없게 됩니다.

**예시:**

```cpp
// 스레드를 구현합니다.
thread launch(string n, int m) {
    int i;
    println(n);
    // 모든 값을 표시합니다.
    for (i = 0; i < m; i++)
        print(i, " ");
    println();
}

function principal() {
    // 스레드를 시작합니다.
    launch("첫 번째", 2);
    launch("두 번째", 4);
}
```

하나의 잠금을 다른 잠금과 구분하기 위해 매우 구체적인 문자열을 사용하는 것이 좋습니다.

## 3. Protected threads

위의 예제는 보호된 함수를 사용하여 정확히 같은 동작을 가진 상태에서 다시 작성될 수 있습니다.

**예시:**

```cpp
// 보호된 함수로 스레드를 다시 구현합니다.
protected thread launch(string n, int m) {
    int i;
    println(n);
    // 모든 값을 표시합니다.
    for (i = 0; i < m; i++)
        print(i, " ");
    println();
}
```

이 함수는 이전 함수와 정확히 같은 출력을 생성합니다. 보호된 스레드는 실행이 시작되자마자 잠금을 설정하고 함수가 종료되면 잠금을 해제합니다. 그러나 보호된 함수 대신 잠금을 사용하는 장점은 보호해야 할 줄을 훨씬 더 정확하게 지정할 수 있다는 것입니다.

## 4. 세마포어: Waitonfalse

위의 함수들은 멀티 스레드 환경에서 유용하지만, 일부 경우에는 충분하지 않습니다. Tamgu는 변수 값에 대해 스레드를 동기화하는 데 사용되는 함수를 제공합니다. 이러한 함수는 부울, 정수, 실수 또는 문자열과 같은 간단한 유형과만 연관될 수 있습니다.

이 두 함수의 역할은 스레드가 특정 변수가 false 값을 도달할 때까지 대기 상태로 들어가도록 하는 것입니다. 숫자 변수의 값이 0일 때, 문자열이 비어 있을 때 또는 부울 변수가 false로 설정될 때 자동으로 false가 반환됩니다.

`waitonfalse(var)`: 변수 `var`이 false 값을 도달할 때까지 스레드를 대기 상태로 만듭니다.

`waitonfalse` 함수는 `principal`과 `launch` 함수를 함께 동기화합니다.

**참고:**

위의 예제는 다음과 같이 `wait`와 `cast`를 사용하여 구현할 수 있습니다:

```cpp
// 스레드를 구현합니다.
thread launch(int m) {
    int i;
    // 모든 값을 표시합니다.
    for (i = 0; i < m; i++)
        print(i, " ");
    cast("end");
}

function principal() {
    // 스레드를 시작합니다.
    launch(10);
    wait("end");
    println("종료");
}

principal();
```

그러나 하나의 `cast`만 스레드를 해제하기 위해 수행될 수 있다는 것을 기억하는 것이 중요합니다. 동기 변수를 사용하면 `waitonfalse`가 `cast`를 수행하는 스레드만이 아니라 다른 스레드에 의해 트리거될 수 있습니다.

## 5. 플래그 join을 사용한 Waitonjoined()

스레드가 계속하기 전에 다른 스레드의 종료를 기다려야 하는 경우, 각각의 스레드를 `join`으로 선언한 다음 `waitonjoined()` 메소드를 사용하는 것이 가장 간단한 해결책입니다.

다른 스레드는 동시에 서로 다른 집합의 조인된 스레드를 기다릴 수 있습니다.