# 탐구 맵

탐구 맵은 문자열 또는 문자열로 분석할 수 있는 요소를 키로 사용하는 해시 테이블입니다. 이 맵은 모든 키를 문자열로 변환하여 "123"과 123을 동일한 키로 간주합니다.

## 맵의 종류

1. **TreeMap**: 맵과 유사하지만 TreeMap의 키는 자동으로 정렬됩니다.
2. **BinMap**: 맵과 유사하지만 값이 0과 65535 사이인 짧은 키입니다. 키는 항상 정렬됩니다. BinMap은 "allmaps" 라이브러리를 통해 사용할 수 있습니다.
3. **PrimeMap**: 키가 소수로 구성된 해시 맵입니다. 이 맵의 장점은 값이 저장된 순서대로 반복할 수 있다는 것입니다.

## 메소드

1. `clear()`: 컨테이너를 지웁니다.
2. `find(value)`: 값이 맵에 속하는지 테스트하고 'true' 또는 해당 키를 반환합니다.
3. `invert()`: 키/값을 반전시킨 맵을 반환합니다.
4. `items()`: {키:값} 쌍의 벡터를 반환합니다.
5. `join(string sepkey, string sepvalue)`: 컨테이너의 문자열 표현을 생성합니다.
6. `json()`: 컨테이너와 일치하는 JSON 호환 문자열을 반환합니다.
7. `keys()`: 맵의 키를 벡터로 반환합니다.
8. `merge(v)`: v를 맵에 병합합니다.
9. `pop(key)`: 맵에서 요소를 삭제합니다.
10. `product()`: 요소들의 곱을 반환합니다.
11. `size()`: 요소의 개수, 즉 컨테이너의 크기를 반환합니다.
12. `sum()`: 요소들의 합을 반환합니다.
13. `test(key)`: 키가 맵 컨테이너에 속하는지 테스트합니다.
14. `values()`: 맵의 값들을 벡터로 반환합니다.

## 초기화

맵은 다음 형식의 설명으로 초기화할 수 있습니다: `{ "k1":v1, "k2":v2, ... }`

예시:
```cpp
map toto = { "a":1, "b":2 };
```

## 연산자

- `x in amap`: 수신 변수에 따라 true 또는 인덱스 목록을 반환합니다. 맵에 문자열 값이 포함된 경우 시스템은 테스트한 값과 동일한 문자열인 경우에만 true 또는 해당 인덱스를 반환합니다. `in` 연산자는 로컬 문자열 내에서 수행되지 않습니다.
- `for (s in amap) { ... }`: 모든 키를 순환합니다. 각 반복에서 `s`는 `amap`의 키를 포함합니다.
- `+`, `*`, `-`, `/` 등: 맵의 각 요소에 값을 추가하거나 맵의 각 요소를 키를 따라 다른 맵에 추가합니다.
- `&`, `|`: 두 맵의 교집합 또는 합집합을 키를 따라 결합합니다.

## 인덱스

- `map[key]`: 키가 `key`인 요소를 반환합니다. `key`가 맵의 키가 아닌 경우 `null`이 반환됩니다.

## 크기

- 정수 또는 부동 소수점으로: 맵의 크기를 반환합니다.
- 문자열로: 맵 초기화 구조를 모방하는 문자열을 반환합니다.

## 예시

```cpp
map vmap;
vmap["toto"] = 1;
vmap[10] = 27;
print(vmap); // 출력: {'10':27, 'toto':1}
```

## 키 테스트

맵이 특정 키를 포함하는지 테스트하는 다양한 방법이 있습니다. 첫 번째 방법은 `test` 연산자를 사용하여 true 또는 false를 반환하는 것입니다. 다른 방법은 컨테이너에 잘못된 인덱스가 제공되었을 때 오류를 잡는 것입니다. 그러나 `test`를 사용하여 동등성을 확인하는 대신에 `test`를 사용하는 것이 더 빠르고 효율적입니다.

예시:
```cpp
if (m.test("ee"))
    println("ee is not a key in m");

// 컨테이너에서 잘못된 키를 사용할 때 예외를 피하기 위해 다음 코드를 사용합니다:
erroronkey(false);
if (m["ee"] == empty)
    println("ee is not a key in m");
```