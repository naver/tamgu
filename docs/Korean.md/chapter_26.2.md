## 방법

1. `add(container, bool norm, int encoding)`: 컨테이너(벡터 또는 맵)를 변환하여 전이형 렉시콘으로 만듭니다. 컨테이너가 벡터인 경우, 값의 개수는 짝수여야 합니다.

2. `build(string input, string output, bool norm, int encoding)`: 텍스트 파일에서 전이형 파일을 빌드합니다. 텍스트 파일은 첫 번째 줄에 표면 형태를, 다음 줄에는 렘마+특징을 포함해야 합니다.

3. `compilergx(string rgx, svector features, string filename)`: 정규 표현식에서 전이형 파일을 빌드합니다. `filename` 매개변수는 선택적입니다. 결과 자동화기는 파일에 저장됩니다.

4. `load(string file)`: 전이형 파일을 로드합니다.

5. `lookdown(string lemFeat, byte lemma)`: 특징과 일치하는 렘마를 가진 표면 형태를 검색합니다. `lemma` 매개변수는 선택적입니다. 1 또는 2로 설정하면 비교 대상 문자열을 렘마만으로 줄일 수 있습니다. `lemma`이 2인 경우, 특징도 반환됩니다. 중요: 렘마는 특징과 탭으로 구분되어야 합니다.

6. `lookup(string wrd, int threshold, int flags)`: 전이형과 잠재적인 작업 집합 및 임계값을 사용하여 단어를 조회합니다. 마지막 두 매개변수는 생략할 수 있습니다. 잠재적인 작업은 다음과 같습니다:
   - `a_first`: 자동화기는 첫 번째 문자에 작업을 적용할 수 있습니다. 이 작업이 설정되지 않은 경우, 비교 대상 문자열은 모두 이 문자로 시작합니다. 이 문자가 자동화기에 없는 경우, 시스템은 이 모드로 전환합니다.
   - `a_change`: 자동화기는 문자를 다른 문자로 변경할 수 있습니다.
   - `a_delete`: 자동화기는 문자를 삭제할 수 있습니다.
   - `a_insert`: 자동화기는 문자를 삽입할 수 있습니다.
   - `a_switch`: 자동화기는 두 문자를 교환할 수 있습니다.
   - `a_nocase`: 자동화기는 두 문자가 대소문자에 관계없이 일치하는지 확인합니다.
   - `a_repetition`: 자동화기는 문자가 몇 번 반복되는 것을 허용합니다.
   - `a_vowel`: 자동화기는 강조 기호가 없는 모음을 함께 비교합니다. 예를 들어, "e"는 "é" 또는 "è"와 일치하지만 "a"와는 일치하지 않습니다.
   - `a_surface`: 자동화기는 표면 형태만 반환합니다.

7. `parse(string sentence, int option, int threshold, int flags)`: 전이형을 사용하여 단어 시퀀스를 분석합니다. `option` 매개변수는 다음 값을 가질 수 있습니다:
   - `0`: 초기 문자열에서 인식된 표면 형태만 반환합니다.
   - `1`: `0`과 동일하지만 오프셋을 포함합니다.
   - `2`: 초기 입력에서 인식된 표면 형태와 렘마와 특징을 반환합니다.
   - `3`: `2`와 동일하지만 오프셋을 포함합니다. `threshold`와 `flags`는 선택적이며, `lookup`과 동일한 규칙을 따릅니다.

8. `store(string output, bool norm, int encoding)`: 전이형을 파일로 저장합니다. 마지막 두 매개변수는 선택적입니다.