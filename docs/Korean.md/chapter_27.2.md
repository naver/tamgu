# 어노테이터 메서드

"annotator" 유형은 규칙에서 추출된 정보를 조사하기 위해 여러 가지 메서드를 제공합니다. 이러한 메서드는 다른 섹션으로 구성되어 있습니다.

## 컴파일

프로그램에 규칙을 추가하는 두 가지 방법이 있습니다. 규칙을 코드에 직접 입력하여 모든 규칙에 대한 단일 저장소를 생성할 수 있습니다. 또는 규칙을 문자열에 저장하고 해당 문자열을 어노테이터 변수를 사용하여 컴파일 할 수 있습니다.

1. `compile(string rules)`: "rules" 문자열에 저장된 규칙을 어노테이터 변수로 컴파일합니다. 이 변수만이 이러한 규칙에 액세스 할 수 있습니다. 또한 선언 시 문자열을 어노테이터 변수에 전달하면 `compile` 메서드를 호출하는 것과 동일합니다.
   예시: `annotator r(ruleCode);`

## 규칙 선택

여러 개의 어노테이터를 병렬로 실행할 수 있으며, 각각이 특정 레이블 집합에 해당합니다. 예를 들어, "lab1"과 "lab2" 레이블을 모든 규칙과 연결하여 어노테이터 변수에 할당할 수 있으며, 해당 레이블을 가진 규칙만 적용됩니다.

2. `select(uvector labels)`: "labels" 벡터에 정의된 레이블을 가진 규칙을 선택합니다.
3. `clear()`: 레이블 선택을 지웁니다.
4. `selection()`: 레이블 선택을 반환합니다.

## 어휘

이 메서드는 어노테이터에 일반적인 목적의 트랜스듀서 어휘를 연결합니다. 일반적인 목적의 어휘는 영어, 프랑스어 또는 한국어와 같은 특정 자연 언어의 어휘입니다. 동시에 여러 개의 어휘를 가질 수 있지만, 제공된 첫 번째 어휘가 문자열 토크나이징에 사용됩니다.

5. `lexicon(transducer t)`: 사용 가능한 경우 초기 언어 사전을 설정합니다.

## 규칙 적용

다음 메서드는 문자열 또는 문자열 벡터에 규칙을 적용하는 데 사용됩니다.

6. `compilelexicons()`: 어휘를 사전 컴파일합니다. 파싱하기 전에 호출되지 않으면 첫 번째 파싱에서 컴파일되어 지연이 발생할 수 있습니다.
7. `spans(bool)`: true로 설정하면 주석 클래스와 해당 오프셋을 모두 반환하고, false로 설정하면 주석 클래스만 반환합니다.
8. `parse(ustring txt, bool keeplex)`: ustring에 규칙을 적용합니다.
9. `apply(uvector tokens, bool keeplex)`: 토큰 벡터에 규칙을 적용합니다.
10. `apply(vector morphos, bool keeplex)`: 형태소 분석된 토큰 벡터에 규칙을 적용합니다. 벡터의 각 요소는 적어도 두 개의 요소 [단어, 원형, 특징1, 특징2..]를 포함해야 합니다. 여기서 "단어"는 표면 형태, "원형"은 원형 형태이고, "특징1, 특징2.."는 특징 목록입니다.
    예시: 입력 "the dogs"의 경우: `[[“the”, “the”,”det” ,”definite”], [“dogs”,”dog”,”noun”,”plural"]]`
11. `apply(annotator, bool keeplex)`: 이전 어노테이터 파싱 또는 적용으로 계산된 구조에 규칙을 적용합니다. 이를 통해 단일 토크나이징과 규칙의 여러 패스를 사용할 수 있습니다.

## 파싱

파싱 중에는 지금까지 어노테이터에 의해 추출된 내부 구조에 액세스할 수 있습니다. 다음 메서드는 콜백 함수에서 사용할 수 있으며, 분석을 향상시키기 위해 사용될 수 있습니다.

### 레이블 액세스

12. `checklabel(ustring label)`: 레이블이 주석 텍스트에 속하는지 확인합니다.
13. `labels()`: 추출된 모든 레이블의 목록을 반환합니다.

### 토큰 액세스

14. `words()`: 텍스트에서 발견된 모든 단어의 목록을 반환합니다.
15. `tokens()`: 텍스트에서 추출된 토큰의 시퀀스를 반환합니다.
16. `tokenize(ustring txt)`: "txt"에 어휘를 적용하고 토크나이징을 반환합니다. 또한 연관된 함수를 적용합니다.

### 단일 토큰 액세스

17. `checkword(ustring wrd)`: 단어가 주석 텍스트에 속하는지 확인하고 주석 목록을 반환합니다.
18. `word(ustring w)`: 텍스트에서 단어(또는 원형)가 감지되었는지 여부를 반환합니다.
19. `token()`: 현재 단어 또는 해당 인덱스를 반환합니다. 수신 변수가 문자열인지 정수인지에 따라 달라집니다.
20. `token(long idx)`: "idx" 위치에 있는 토큰 자체를 반환합니다.

## 종속성

21. `dependencies(bool clear)`: 모든 주석을 지식 베이스에 종속성으로 저장합니다(종속성에 대한 자세한 내용은 섹션 46을 참조하십시오). 각 토큰은 synode로 변환되고, 각 주석은 synode와 매개변수로 변환됩니다. "clear" 매개변수는 선택 사항이며 true로 설정하면 새 항목을 받기 전에 지식 베이스가 지워집니다. 어노테이터가 다른 어노테이터와 공유되면 해당 synode도 공유되므로 새로운 종속성은 동일한 synode를 공유합니다.

컴파일과 직접 선언의 차이점은 무엇인가요?

예를 들어보겠습니다:
a) 먼저 다음 규칙을 코드에 직접 선언합니다:

위 예제에서 "r1"은 "rule1"의 규칙을 포함하고, "r2"는 "rule2"의 규칙을 포함합니다. 이 경우 두 어노테이터는 동일한 규칙 저장소를 공유하지 않으며, 각각 자체 저장소를 가집니다.