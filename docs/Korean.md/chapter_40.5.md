## 기능

Taskell 언어는 함수를 선언하는 방법을 제공합니다. 이러한 함수는 어디에서나 선언할 수 있으며 Tamgu 함수로 호출할 수도 있습니다.

### Taskell 함수를 선언하는 방법은?

함수는 다음과 같은 방식으로 선언됩니다:

```taskell
<name(a1, a2...) = Taskell 표현식>
```

Tamgu 프로그램에서 다음과 같이 호출할 수 있습니다: `name(p1, p2...)`.

예시:

```taskell
<one(x) = x + 1>
int val = one(12);
println(val); // val은 13입니다.

<plusone(v) = x + 1 | x <- v>
vector vect = plusone([1..10]);
println(vect); // vect는 [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]입니다.
```

함수 인수 목록 선언은 true Haskell에서 정의된 것과 다릅니다.

### 인수 유형 설명

함수가 반환 및 인수 유형을 처리하는 방법을 간단한 규칙으로 설명할 수 있습니다.

함수 이름 뒤에 연산자 "::"를 사용하여 인수 유형과 반환 유형을 선언합니다.

```taskell
<MyFunc :: int -> int -> int>
```

마지막 "->" 다음의 마지막 요소는 반환 유형입니다. 인수의 크기는 함수의 크기와 일치해야 합니다.

인수 중 하나가 함수여야 하는 경우, 유형은 "call"입니다. 다시 말하지만, 이는 Haskell과 다른 점으로 더 정교한 설명이 가능합니다.

중요: 선언을 제공하면 이후의 MyFunc 구현은 동일한 선언을 상속합니다.

목록에서 특정 유형이 필요하지 않은 인수는 "_"로 대체할 수 있습니다.

```taskell
<Test :: int -> _ -> vector ...>
```

이 예시에서 두 번째 인수는 특정 유형을 요구하지 않습니다.

예시:

```taskell
<Mult :: int -> _ -> float -> float>
<Mult(x, y, z) = 3 * x - y + z>
int j = 17 + Mult(10, 2, 3);
println(j); // 결과는 48입니다 (Mult의 첫 번째 정의)
```

### Taskell 표현식에서의 선언

함수와 마찬가지로 Taskell 표현식에도 반환 유형을 추가할 수 있습니다. 단, 이 경우 매개변수는 비어 있어야 합니다.

```taskell
<:: ivector x | x <- [1..10]> // 이 표현식은 ivector를 반환합니다.
```

### 선언 없이

선언 없이 Taskell 함수를 선언하면, Tamgu는 각 비원자 요소를 "self" 변수로 선언합니다.

따라서 "plusone" 선언은 다음과 동일합니다:

```taskell
function plusone(self, v) {...}
```

하지만 이러한 함수의 인수는 정수, 부동 소수점 또는 문자열과 같은 원자값 또는 벡터 선언일 수 있습니다.

### 여러 선언

하나의 Taskell 표현식에서 함수를 여러 개 선언할 수 있습니다. 이 경우 인수 목록에는 원자값이 포함될 수 있습니다. 표현식이 평가될 때, 매개변수는 함수의 인수와 일치 여부를 확인합니다. 일치하는 것이 없다면 시스템은 다음 선언을 시도합니다.

예시:

```taskell
<fibonacci(0) = 0>
<fibonacci(1) = 1>
<fibonacci(n) = a | let a = fibonacci(n - 1) + fibonacci(n - 2)>
fibonacci(10); // 55를 반환합니다.
```

"n"이 0 또는 1일 때, 첫 번째 또는 두 번째 정의와 일치하므로 적절한 값을 반환합니다.

### break

"break"는 현재 함수 선언을 "실패"시키는 데 사용할 수 있습니다. 예를 들어, 요소 수가 특정 값보다 큰 경우 다음 선언으로 이동하려는 경우가 있을 수 있습니다.

예시:

```taskell
<myloop(v): if (v.size() > 10) break else v[0]>
<myloop(v): v[10]>
<myloop([1..10])> // 1을 반환합니다. 리스트 크기는 10입니다.
<myloop([1..20])> // 11을 반환합니다. 리스트 크기는 20입니다.
```

### case x of pattern -> result, pattern -> result... otherwise result

이 명령은 switch case와 매우 유사하지만 큰 차이점이 있습니다. x를 패턴과 비교하고 값뿐만 아니라 패턴도 제공할 수 있습니다. 예를 들어, 리스트 패턴을 지역 변수를 생성하는 방법으로 사용할 수 있습니다.

예시:

```taskell
// 이 경우, 각 값에 대해 1, 2와 비교하여 12, 24 또는 34를 반환합니다.
vector v = <case x of 1 -> 12, 2 -> 24 otherwise 34 | x <- [1..10]>;
println(v); // v는 [12, 24, 34, 34, 34, 34, 34, 34, 34, 34]입니다.

// [1, 2, 3, 4], ..., [1, 2, 3, 4]로 구성된 벡터를 준비합니다.
vector v = <replicate 5 [1..4]>;
println(v); // v는 [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]입니다.

// 서브 리스트를 벡터 패턴과 일치시킵니다.
vector v = <case x of [a, b] -> (a + b), [a, b, c, 4] -> (a + b - c) otherwise <sum x> | x <- v>;
println(v); // v는 [0, 0, 0, 0, 0]입니다.
```

### 인수에서의 리스트 반복

Taskell은 Prolog과 매우 유사한 방식으로 리스트를 반복할 수 있습니다. Prolog에서와 같이 "|" 연산자를 사용하거나 리스트를 분할하는 데 Haskell에서와 같이 ":" 연산자를 사용할 수 있습니다.

예시:

```taskell
<see([]) = "empty">
<see([first:rest]) = [a, first] | let a = see(rest)>
see(['a'..'e']); // 결과는 [[[[['empty', 'e'], 'd'], 'c'], 'b'], 'a']입니다.
```