## 평가 시작하기

평가는 함수와 동일한 방식으로 시작됩니다. 원하는 만큼의 추론 변수를 제공할 수 있지만, 한 번에 하나의 predicate만 시작할 수 있습니다. 여러 개의 predicate를 포함하려면 먼저 표현식을 절로 선언해야 합니다.

### 중요 사항

수신 변수가 벡터인 경우, 모든 가능한 분석이 제공되고 평가 트리가 완전히 탐색됩니다. 수신 변수가 다른 형식인 경우, 솔루션이 찾아지는 즉시 평가가 중지됩니다.

### 메소드를 Predicate로 매핑하기

대부분의 객체 메소드는 간단한 방식으로 predicate로 매핑됩니다. 예를 들어, 문자열이 "trim" 메소드를 내보낸다면, "p_trim"이라는 두 개의 변수를 가진 predicate가 생성됩니다. 각 메소드는 "p_" 접두사를 추가하여 predicate로 매핑됩니다.

이 predicate의 첫 번째 인자는 메소드의 헤드 객체이고, 마지막 매개변수는 그 객체에 이 메소드를 적용한 결과입니다. 예를 들어, `s`가 문자열이고 `s.trim()`이 호출되면, `p_trim(s,?X)`가 됩니다. 여기서 `?X`는 `s`에 `trim`을 적용한 결과입니다. `?X`가 통일되면, predicate는 `?X`가 `s.trim()`과 동일한지 확인합니다.

**예시:**
`compute(?X,?Y) :- p_log(?X,?Y).`  
`between(?X,?B,?E), succ(?X,?Y)`

- `between(?X,?B,?E)`는 값 `?X`가 `?B`와 `?E` 사이에 있는지 확인합니다.
- `succ(?X,?Y)`는 `?X`의 다음 값(후계자)을 반환합니다. `succ`는 터미널로 사용될 수도 있지만, 그 경우에는 하나의 인자만 사용합니다.

### Tamgu 변수와 관련된 일반적인 실수

문자열 `s`, 정수 `s` 또는 기타 유형의 변수와 같은 일반적인 변수를 predicate에서 사용하는 경우, 이러한 변수는 비교 값으로 사용된다는 점을 기억해야 합니다. 이를 명확히 설명하기 위해 다음 예시를 살펴보겠습니다:

**예시 1:**
```
string s = "test";
string sx = "other";
predicate comp;
comp._trace(true);
comp(s, 3) :- println(s).
comp(sx, ?X).
```
**실행 결과:**
```
r:0 = comp(s, 3) --> comp(other, ?X172) --> 실패
```
이 절은 `s`와 `sx`가 서로 다른 값을 가지고 있기 때문에 실패했습니다.