## 종속성 유형

종속성은 두 개의 synode 간의 관계입니다. 종속성은 직접적으로 유형 종속성을 통해 생성되어 `assertz`를 사용하여 지식 베이스에 저장되거나 종속성 규칙을 사용하여 저장될 수 있습니다. 종속성은 이름, 피처 세트 및 인수 목록으로 구성됩니다.

### 메소드

`Dependency` 클래스는 다음과 같은 메소드를 노출합니다:

1. `_initial([name, features, arg1, arg2, ...])`: 이름 (문자열), 피처 세트 (맵) 및 synode 유형의 인수 목록을 사용하여 종속성을 생성합니다.
2. `features()`: 종속성 피처를 반환합니다.
3. `name()`: 종속성 이름을 반환합니다.
4. `rule()`: 이 종속성을 생성한 규칙 ID를 반환합니다.

예시:

```java
// 두 개의 어휘 노드를 생성합니다
Synode det({"pos" :"det", "surface" :"the"});
Synode noun({"pos" :"noun", "surface" :"dog"});
Dependency d(["DET", {"direct" : "+"}, det, noun]);

// 지식 베이스에 추가합니다
assertz(d);
println(d);
```

결과: `DET['direct' : '+']({"pos" :"det", "surface" :"the"}, {"pos" :"noun", "surface" :"dog"})`

### 종속성 규칙

종속성 규칙은 다음 패턴과 일치합니다:

```
If ([^|~] dep[features] (#x[features], #y) and/or dep(#w, #z)...)
depres(#n, #nn), ..., depres(#n, #nn) / ~ / #x[..], #x[..]
```

여기서 `x`, `y`, `w`, `z`, `n`, `nn`은 정수입니다.
- 각각의 `#x`는 지식 베이스 종속성의 실제 synode와 일치할 것입니다.
- 종속성은 `^` 또는 `~`로 시작할 수 있습니다.
- 종속성 이름은 `_n`으로 대체할 수도 있습니다. 여기서 `n`은 정수입니다. 이러한 변수를 사용하여 종속성 또는 종속성 이름을 비교할 수 있습니다. 종속성 결과에 이러한 변수 중 하나를 사용하면 변수에 기록된 종속성 이름이 이 새로운 종속성을 생성하는 데 사용됩니다. `_n`은 메모리에 있는 어떤 종속성이든 일치하면 사용할 수 있습니다. 단, 그들의 아리티가 일치해야 합니다.
- 피처 구조에 대한 설명은 아래에서 확인하십시오.

**참고**: 이러한 규칙을 시작하는 `If`는 항상 대문자 "I"로 시작해야 합니다. 그렇지 않으면 시스템은 규칙을 일반적인 "if" 부울 표현식으로 분석하려고 시도할 것입니다.

이 규칙은 지식 베이스에 저장된 종속성과 일치하는 지식 베이스의 종속성이 있는 경우, 동일한 변수를 사용하여 일부 새로운 종속성을 저장합니다. 이 규칙은 함수 호출, 술어 및 종속성을 혼합하여 사용할 수 있습니다.

`^`는 이 종속성이 수정될 것임을 의미합니다. 규칙에서 한 번에 하나의 종속성만 수정될 수 있습니다.

`~`는 부정을 의미합니다. 종속성 앞에 오면 지식 베이스에 해당 종속성이 존재해서는 안 된다는 것을 의미합니다.

규칙의 출력을 `~`로 대체하면 규칙이 적용되지만 종속성은 생성되지 않습니다.

### 사실

지식 베이스에 종속성을 추가하는 가장 간단한 방법은 사실로 삽입하는 것입니다.

```
dep[features](#1, #2).
```

### 피처

종속성 규칙의 피처 구조는 특정 규칙을 따릅니다:
- 첫째로, 속성과 값 주위의 따옴표는 선택적입니다.
- 둘째로, "+"는 하나의 값이 있는 속성의 기본값입니다.

**연산자**:
- `attribute`: 속성의 존재 여부를 확인합니다.
- `attribute : value`: 속성을 값과 비교합니다.
- `attribute : ~`: 속성은 어떤 값을 가져서는 안 됩니다.
- `attribute ~: value`: 속성은 값이어서는 안 됩니다.
- `attribute = value`: 속성에 값을 할당합니다.
- `attribute = ~`: 속성을 피처 세트에서 제거합니다.
- `attribute -: gram`: 속성을 TREG (Tamgu 정규 표현식)와 비교합니다.
- `attribute ~ -: gram`: 속성을 실패해야 하는 TREG와 비교합니다.

### 중지

문법의 평가를 중지하는 술어 `stop`을 사용하여 문법의 평가를 중지할 수도 있습니다. 아래 예시에서 볼 수 있습니다:

```
If (stop) ~.
```

이 규칙은 문법의 어디에나 배치할 수 있습니다. 평가 엔진이 이 규칙에 도달하면 문법의 평가를 중지합니다. 그런 다음 다음 규칙은 완전히 건너뜁니다.

### _dependencies()

이 메소드는 지식 베이스에 대해 규칙을 적용하여 종속성 분석을 트리거합니다.

### _setvalidfeatures(mapss features)

이 메소드는 synode 및 종속성에 사용할 수 있는 유효한 피처에 대한 제약 조건을 설정합니다. 피처는 맵에서 키/값 구조에 대해 속성/값으로 매핑된 것입니다. 단어의 렘마와 같이 어떤 속성이 어떤 값을 가질 수 있는 경우, 값은 빈 문자열이어야 합니다. 기본값은 "+"입니다.

예시:

```java
mapss feats = {'Obl': '+', 'lemma': '', 'c_person': '+', 'CR4': '+', 'Punct': '+', 'surface': ''};
_setvalidfeatures(feats);
```