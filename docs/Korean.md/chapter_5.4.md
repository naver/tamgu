# 스레드

스레드 함수가 실행되면 독립적인 시스템 스레드로 실행됩니다.

예시:

```cpp
int toto(int i) {
    i += 10;
    return i;
}

int j = toto(10);
print("J=" + j + "\n");
```

실행 결과:

```
J=20
```

## 보호된 스레드

"보호된"은 두 개의 스레드가 동시에 동일한 코드 라인에 접근하는 것을 방지합니다.

보호된 스레드는 시작할 때 잠금을 설정하고, 함수 실행이 완료되면 잠금을 해제합니다. 이로써 보호된 함수에 대한 서로 다른 호출은 순차적으로 이루어지고 동시에 실행되지 않습니다. 보호된 함수는 재진입(reentrant)이 아닌 코드에 사용되어야 합니다.

예시:

```cpp
protected thread launch(string n, int m) {
    int i;
    println(n);
    for (i = 0; i < m; i++)
        print(i + " ");
    println();
}

function principal() {
    launch("Premier", 2);
    launch("Second", 4);
    println("End");
}

principal();
```

출력 결과:

```
End
Premier
0 1
Second
0 1 2
```

## 배타적 스레드

배타적 스레드는 보호된 스레드와 매우 유사하지만 한 가지 차이가 있습니다. 보호된 스레드의 경우 보호는 메소드 수준에서 이루어지지만, 배타적 스레드의 경우 프레임 수준에서 이루어집니다. 이런 의미에서 배타적은 자바의 synchronized와 정확히 동일하게 작동합니다.

보호된 함수의 경우 한 번에 한 스레드만 이 메소드에 접근할 수 있습니다. 그러나 메소드가 배타적인 경우 한 번에 한 스레드만 프레임 객체에 접근할 수 있습니다. 이는 서로 다른 인스턴스 내에서 해당 메소드가 실행되면 다른 스레드가 동일한 메소드를 실행할 수 있다는 의미입니다.

다시 말해, 보호된 스레드에서는 메소드에 속하는 잠금을 사용하고, 배타적 스레드에서는 프레임 인스턴스에 속하는 잠금을 사용합니다.

예시:

```cpp
frame disp {
    exclusive thread edisplay(string s) {
        println("Exclusive: " + s);
    }

    protected thread pdisplay(string s) {
    }
}

for (i = 0; i < 100; i++)
    v[i].pdisplay();

for (i = 0; i < 100; i++)
    v[i].edisplay();

for (i = 0; i < 100; i++)
    v[i].display(c);
```

## Joined와 Waitonjoined

스레드는 메인 스레드가 자신의 코드를 완료하기 전에 시작된 모든 스레드의 완료를 기다려야 하는 경우에 결합된(joined)로 선언될 수 있습니다. 이러한 스레드가 완료될 때까지 기다리기 위해 waitonjoined()를 사용할 수 있습니다.

다른 스레드에서 필요한만큼 많은 waitonjoined()를 사용할 수 있습니다. waitonjoined()는 주어진 스레드 내에서 시작된 "결합된 스레드"에 대해서만 대기합니다.

## 원자값

대부분의 데이터 구조(맵, 벡터, 문자열 등)는 락을 통해 스레드로부터의 동시 접근으로부터 보호됩니다. 그러나 이러한 락은 종종 시간과 공간 면에서 비용이 많이 듭니다. Tamgu는 a_int, a_string 또는 a_mapii와 같은 특정 락-프리 데이터 구조(또는 원자형)를 제공합니다. 이러한 데이터 구조는 스레드가 대기하지 않고도 훨씬 효율적으로 기계를 사용할 수 있게 해줍니다. 그러나 구현 방식으로 인해 스레딩 컨텍스트가 아닌 경우 다른 유형보다 느릴 수 있습니다. 이러한 데이터 구조는 스레드간에 공유되는 경우에만 유용합니다.

## 스트림 연산자 '<<<'

스레드를 시작할 때, 해당 스레드의 결과를 호출 코드와 연결 없이 직접 변수에 저장할 수 없습니다. 이 작업을 위해 Tamgu는 특정 연산자인 <<<, 또는 스트림 연산자를 제공합니다. 스트림은 스레드와 연결된 변수로써, 스레드가 반환하는 값들을 해당 변수에 저장할 수 있게 합니다. 물론, 변수는 스레드와 독립적으로 존재해야 합니다.

예시:

```cpp
joined thread Test(int i) {
    return (i * 2);
}

function launch() {
    treemapi m;
    int i = 0;
    for (i in <0, 10, 1>)
        m[i] <<< Test(i);
    waitonjoined();
    println(m); //{0:0,1:2,2:4,3:6,4:8,5:10,6:12,7:14,8:16,9:18}
}

launch();
```