14 Type rawstring, string , ustring in Tamgu
The string  type is used to handle any sorts of string. It provides many different 
methods to extract a substring, a character or applies any pattern recognition 
on the top of it.  
• The ustring type is used to offer a much faster access to very large 
strings , as the s ystem assumes only one single encoding for the 
whole string . The “u” stands for “ Unicode”.  ustring is based on the 
wstring  implementation in C++.  
• The rawstring type is quite different. It accepts string but handles 
them at the byte level. Furthermore, whe n you create a rawstring  
element, you must provide either its size or an initial string, whose 
size would be used to bound the variable. The string will not accept 
characters outside its boundaries, unless you resize it. A rawstring  
does not require specif ic protection in threads and can be access ed 
and modified freely. However, you can not resize a rawstring  if 
threads are running in the background.  Since, the string is handled 
at the byte level, the access is very fast, as the system will not try to 
assess  any UTF -8 characters as in the string  type.  
Example : 
rawstring  rd(100);  
rd="toto" ; 
println (rd[0],rd[1],rd[2],rd[3],rd[4],rd[5],rd[6]); 
//since, the string is managed at the byte level, UTF -8 is not recognized: c l i c h Ã © 
14.1 Methods  
In the following methods, rgx follows the Tamgu  regular expression formalism 
or TREG  (see the chapter dedicated to these expressions).  
1. base(int b , bool toconvert ): return the numerical value 
corresponding to the string  numeric content  in base b.  
toconvert  is optional. When it is false, the number to be 
converted is in base 10 and is converted to base b.  
2. base(vector chrs): Set the encoding for each digit in a  given  
base. The default set is 64 characters: 0 -9,A-Z,a-z,#,@.  
 57. trim(): remove the trailing characters  
58. trimleft(): remove the trailing characters on the left  
59. trimright(): remove the trailing characters on the right 
60. upper(): Return the string in upper characters  
61. utf8(): convert a LATIN string into UTF8  
62. utf8(int part): convert a Latin string, encoded into ISO 8859 
part part into utf8. For instance, s.utf8(5), means that the string 
to be converted in UTF -8, is encoded in ISO 8859 part 5 
(Cyrillic). See below for a description of each part.  
63. write(string file): write the string content into a file   
14.2 String Handling  
There are a number of methods and implementation that are specific to 
strings.  
Korean specific metho ds (only for string and ustring)  
1. ishangul(): return true if it is a Hangul character.  
2. isjamo(): return true if it is a Hangul jamo.  
3. jamo(bool combine): if 'combine' is false  or absent:  split a Korean jamo 
into its main consonant and vowel components, else combine content 
into a jamo.  
4. normalizehangul(): Normalize different UTF8 encoding of Hangul 
characters  
5. romanization(): Romanization  of Hangul characters.  
Latin Table  
(from  https://en.wikipedia.org/wiki/ISO/IEC_8859 ) 
Use the number associated to “Part” in the first column with the utf8 method.  
 Latin -1 
Western 
European  Perhaps the most widely used part of ISO/IEC 
8859, covering most Western European 
languages:  Danish  (partial),[1] Dutch  (partial),[2]Englis
The “Part” number is the index through  which encoding s are accessed.  
Note: The table part 17, which is not mentioned here,  is an addendum to 
handle “Windows 1252 Latin 1  (CP1252) ” encoding.  
Encoding Names  
Since, using a number to refer to the right encoding is quite cumbersome , 
Tamgu provides the following constant value to access these encodings:  
• e_latin_we  =1 :  Western European  
• e_latin_ ce = 2:  Central European  
• e_latin_se  = 3:  South European  
• e_latin_ne  = 4:  North European  
• e_cyrillic  = 5:  Cyrillic  
• e_arabic  = 6: Arabic  
• e_greek  = 7:  Greek  
• e_hebrew  = 8:  Hebrew  
• e_turkish  = 9:   Turkish  
• e_nordic  = 10:   Nordic   
Part 11  Latin/Thai  Contains characters needed for the  Thai language . 
Virtually identical to  TIS 620 . 
Part 12  Devanagari  The work in making a part of 8859 
for Devanagari  was officially abandoned in 
1997.  ISCII  and Unicode/ISO/IEC  10646 cover 
Devanagari.  
Part 13  Latin -7 
Baltic Rim Added some characters for Baltic 
languages which were missing from Latin -4 
and Latin -6. 
Part 14  Latin -8 
Celtic  Covers Celtic languages such as  Gaelic  and 
the Breton language . 
Part 15  Latin -9 A revision of 8859 -1 that removes some 
little-used symbols, replacing them with 
the euro sign  € and the 
letters  Š, š, Ž, ž, Œ, œ, and  Ÿ, which 
completes the coverage 
of French , Finnish  and Estonian . 
Part 16  Latin -10 
South -Eastern 
European  Intended 
for Albanian , Croatian , Hungarian , Italian , Polish , Ro
manian  and Slovene , but also Finnish, French, 
German and  Irish Gaelic (new orthography). The 
focus lies more on letters than symbols. 
The currency sign  is replaced with the  euro sign . 
 • e_thai  = 11:  Thai
• e_baltic  = 13:  BALTIC RIM  
• e_celtic = 14:  Celtic  
• e_latin_ffe = 15:  Extended (French, Finnish, Estonian)  
• e_latin_see = 16: South East European  
• e_windows = 17:  Windows encoding  
• e_cp 1252  = 17:   Windows encoding  (to match the exact name)  
Meta -characters  
If you use strings declared between “”, the n Tamgu  will automatically 
recognize the following meta -characters:  
• \\n, \\r and \\t which are the line feed, the carriage return, and the 
tabulation respectively.  
Function  evaluate  
Tamgu  also recognizes a nother  large set of meta -characters, which are 
automatically translated for you when you use the method “ evaluate ”: 
• Decimal code: \\ddd, which is then translated into the Unicode 
charact er of that code: \\048 is for instance the character ‘0’.  
• Hexadecimal code: \\xhh, which is also translated into the 
corresponding Unicode character: \\x30 is the character ‘0’.  
• Unicode code: \\uhhhh, which is also translated into the 
corresponding Unicode character: \\u0030 is the character ‘0’.  
• &#d(d)(d)(d); which is also tran slated in the corresponding 
Unicode character: &#30; is the character ‘0’. This coding 
occurs in XML and HMTL texts.  
• &namecode; for which a long list of equivalence exists (XML 
and HTML again). For instance: &eaccute; is the character: é.  
Conversely, t he m ethod “html” returns a string in which non ASCII character 
are translated into HTML encoding.  
Emojis  
Tamgu  also keeps a track of emojis ( V.5 beta  Unicode 2017), whose list can 
be gathered with the procedure: emojis() , which returns a treem apls object, 
where the key is the emoji  Unicode and the value its textual description in 
 English. Furthermore, Tamgu  provides two methods isemoji and emoji , which 
indicates whether a string is composed of emojis or their description.  
Operators  
sub in s: test if sub is a s ubstring of s . If sub is a TREG and the recipient 
variable a ivector  then Tamgu returns both the beginning and the end of the 
strings that were detected with the regular expression.  
for (c in s) {…}: loop among all characters . At each iteration , c contains a 
character from s.  
+: concatenate two strings.   
“…”: define a string, where meta -characters such as “ \\n”,”\\t”,”\\r”,”\\”” are 
interpreted.  
‘…’: define a string, where meta -characters are not interpreted.  This string 
cannot contain the character “’ ”. 
Indexes  
str[i]:  return the ith character of a string   
str[i:j]: return the substring between  i and j. i and j can be substrings, which 
the system will use to extract the substring.  
str[s.. ]: return the substring starting at string s.  
str[-s..]: return the substring starting at string s. In this case,  s is searched 
from the end of the string.  
N.B. When i and j are positive integers, they are treated as absolute positions 
within the string. However, when the values are negative, they are considered 
as offsets to be counted from each string extremities. However, if the first 
element of the interval is a substring and the second one is a positive integer, 
then this second index will be treated as an offset from the rightmost position 
of where the substring was found.   
You can also modify a character range.  
Example:  
string  s="This is a cliché, which contains a 'é'" ; 
s[10:16]  cliché     //absolute position s 
s["cliché" :7] cliché, which    //offset from end of substring  
s["cliché" :-4] cliché, which contains a  //offset from end of string  
s[-"a":]  a 'é' //looking for last instance of a  
s[-"a":]="#" This is a cliché, which contains #  //replacing a substring  
If an index is out of bounds, then an exception is raised unless the flag 
erroronkey has been set to false.  In that case, Tamgu  will return empty.  
As an integer or a float  
If the string contains d igits, then it is converted into the equivalent number, 
otherwise its conversion is 0.  
format  
A format string contains specific variables, which can be replaced on the fly 
with some content.  
string  frm="this %1 is a %2 of %1 with %3";  
str=frm. format ("test",12,14);  
println (str); //Result: this t est is a  12 of t est with 14  
scan  
There are two different versions for scan .  
The first version takes only one argument and applies the regular expression 
(TREG ) across the whole string, extracting eve ry single target that matches 
the TREG . Each element in that case corresponds to the whole regular 
expression . 
The second version takes a separator. This version of scan considers the 
regular expression as extracting different fields separated with a sepa rator.  
For instance: scan ("%d+, %d+" ,',') considers expressions in which there are 
two integers separated with a “,”. This expression will then return two elements 
for: 12,34 ,45,56  and only two: 12,34.   
Note also, that this version does not return positions for ivector as for the 
other versions.  
 Hence: ivector iv = scan ("%d+, %d+" ,','); 
Will return: [12,34], the values themselves…  
The first method simply splits the string along the regular expression, while 
the second one interpret s the co ntent of that string.  
//A macro to read complex hexadecimal structures  
grammar_macros ("X","({%+ -})0x%x+(.%x+)(p({%+ -})%d+)" ); 
string  s="This: 0x1.0d0e44bfeec9p -3 0x2.09p3 0x3.456aebp -1 in here. "; 
//We use the macro  
string  res=s. scan ("%X" ); 
println ("Res:" ,res);  //Res: 0x1.0d0e44bfeec9p -3 
ivector  iv = s. scan ("%X" ); 
println ("IV",iv); //IV [6,25,26,34]  
svector  vs=s. scan ("%X" ); 
println ("VS",vs); //VS ['0x1.0d0e44bfeec9p -3','0x2.09p3' ,’ 0x3.456aebp -1’] //3 elements  
 //with a separator... The difference here is that  
//the two numbers should be separated with a space  character  
vs = s. scan ("%X %X" ," "); 
println ("VS",vs); //VS ['0x1.0d0e44bfeec9p -3','0x2.09p3']  //2 elements…  
string  reste;  
fvector  fv = s. scan ("%X, %X" ,",",false ,reste)  ; 
println ("FV",fv, reste); //FV [0.131375,16.2812] 0x3.456aebp -1 in here . 
treg string or not treg string?  
In all the examples that have been shown so far, scan  takes as input a string, 
which is then compiled into a treg. It is actually possible to provide a treg 
instead of a string as the first parameter of scan. If this treg is given as a r 
string, then the treg will be compile d at parse time and not at execution time.  
Thanks to this pre -compiling , there is a slight advantage in using treg instead 
of strings at runtime.  
Tokenization Rules  
The methods: parenthetic , tags  and tokenization all use an underlying set of 
tokenization r ules, which can be modified through their rules  parameter.  
This underlying set of rules can be loaded and modified to change or enrich 
the tokenization process, thanks to _getdefaulttokenizerules.  
 - x-   means that the character should be recognized b ut not stored in
the parsing string  
- %.~..   means that all character will be recogniz ed except for t hose in 
the list after the tilde . 
IMPORTANT: do not add any spaces as they would be considered as a 
character to test...  
Example  
svector  rules =_getdefaulttokenizerules (); 
rules .insert (55,"{%a %d}+ : {%a %d}+=0" ); // aaa : bbb is now one token  
rules. insert (55,"{%a %d}+.{%a %d}+=0" );  // aaa.bbb is now one token  
rules. insert (38,"->=0"); // -> is one token  
string  s="this is a test.num -> x : 10 " ; 
//Without rules  
v= s. tokenize (); //['this','is','a','test','.','num',' -','>','x',':','10']  
//With rules  
v= s. tokenize (false ,false , regles); //['this','is','a','test.num',' ->','x : 10']  
parenthetics () or parenthetics (string opening,  string closing)  
Tamgu  also provides a way to decipher parenthetic expressions such as:  
( (S (NP -SBJ Investors)  
     (VP are  
         (VP appealing  
             (PP-CLR to  
      (NP-1 the Securities))  
             (S-CLR (NP -SBJ * -1) 
     not 
     (VP to  
 (VP limit  
     (NP (NP their access)  
 (PP to  
     (NP (NP information)  
 (PP about  
     (NP (NP stock purchases)  
 (PP by  
     (NP "insiders”)  
 ))))))))))).))  
Tamgu  provides a method: parenthetics  which takes as input a structure as 
the one above and translates it into a vector.  
vector  v=s. parenthetics (); //s contains a parenthetic expression as above  
The second function enables the use of different opening or readi ng 
character s. 
Example:  
Tamgu  can analyze the structure  below : 
< <S <NP -SBJ They>  
     <VP make  
         <NP the argument>  
  <PP-LOC in  
  <NP <NP letters>  
      <PP to  
  <NP the agency>>  > > > > .>  
with the following instruction:  
vector  v=s. parenthetics ('<','>');   
tags(string opening, string closing)  
tags is similar to the parenthetics  method except that instead of characters, 
it takes strings as input . You should not  use this method to parse XML output, 
use xmldoc  instead.  
string  s="OPEN This is OPEN a nice OPEN example CLOSE CLOSE 
CLOSE";  
vector  v=s.tags('OPEN ','CLOSE ');   
Output: v=[['this', 'is', ['a','nice ', ['example ']]]; 
 14.3 Examples
//Below are some examples on string manipulations  
string  s; 
string  x; 
vector  v; 
//Some basic string manipulations  
s="12345678a" ; 
x=s[0];  // value=1  
x=s[2:3];   // value=3  
x=s[2:-2];  //value=34567  
x=s[3:];  //value=45678a  
x=s[:"56"];  //value=123456  
x=s["2":"a"];  //value=2345678a  
s[2]="ef";  //value=empty  
//The 3 last characters  
x=s.right(3);  //value=78a  
//A split along a space  
s="a b c" ; 
v=s.split(" ");  //v=["a","b","c"]  
//regex, x is a string, we look for the first match of the regular expression  
x=s.scan( "%d%d%c" );  //value=78a  
//We have a pattern, we split our string along that pattern  
s=’12a23s45e ’; 
v=s.scan( r"%d%d%c" );  // value=['12a','23s','45e' ] 
x=s.replace (r"%d%ds" ,"X"); //value=12aX45e  
//replace also accepts %x variables as in Tamgu  regular expressions  
x=s.replace (r"%d%1s" ,"%1" ); //value=12a2345e  
//REGULAR REGULAR EXPRESSIONS: Not available on all platforms  
preg rgx(p'\\w+day' ); 
string  str="Yooo Wesdenesday Saturday" ; 
vector  vrgx=rgx in str; //['Wesdenesday','Saturday']  
