/@
 Project    : Spreadsheet
 filename   : tamgucalc.tmg
 Date       : 2020/06/15
 Purpose    : spreadsheet for terminals with Lisp expressions
 Programmer : Claude ROUX (claude.roux@naverlabs.com)
@/

/@
Help:

This spreadsheet accepts different sorts of input:

a) Lisp expressions, which should start with a '('
b) Regular formulas, which should start with a '=' and ends with a ';'
c) Long strings, which are introduced with "'"
d) Float numbers, which you input directly
@/

if (version() < "Tamgu 1.2020.07.03.10") {
    _sys.cls();
    println();
    println("Please, accept all our apologies...");
    println("Alas, your version of Tamgu is too old to run 'tamgucalc'...");
    println("We needed to adjust tamgu to run some of the new stuff in tamgucalc...");
    print("Please update it at: ");
    _sys.colors(7,31,107);
    print("https://github.com/naver/tamgu/releases");
    _sys.colors(0,0,0);
    println("\n");
    _exit();
}

//USE -b to switch to black mode
bool chooseblack = false;
//displaying indexes
bool displayindexes = true;
//displaying the message zone
bool displayingmessage = true;

if (_OS == "WINDOWS")
    chooseblack = true;
//The default value for cells
string defaultvalue = ".";

//The Lisp interpreter
lisp lisp_interpreter;
string msgerr;

//Color definition to highlight parenthesis balancing
string colorparenth = _sys.colors(7,31,49, false);
string colorsel = _sys.colors(1, 31, 49, false);
string colorform = _sys.colors(1,30,103, false);
string colornrm = _sys.colors(0,0,0,false);

mapsf definedvalues = {"_pi ":_pi, "_tau ":_tau, "_phi ":_phi, "_e ":_e };

//We keep 6 lines below the grid for input and message display
int inputsection = 6;
//Initialisation: coords contains your terminal dimensions
ivector coords = _sys.screensize();
//columnsize is the size of a column in character. You can modify this value
int columnsize = 10;
//We initialise the number of lines and columns according to your terminal size and columnsize
//We keep 'inputsection' lines below the last line to display messages
int x_viewsize = coords[0]-inputsection;
//The number of columns depends on the number of columns on the screen / the chosen columnsize
int y_viewsize = coords[1]/columnsize;
//We keep these values for comparison when the size is modified
int x_maxview = x_viewsize;
int y_maxview = y_viewsize;
//These two values define the actual matrix size, which is different from viewsize
//If the view port is larger than 101 and 51, then the matrix is equal to the viewport
int x_max = max(257,x_maxview);
int y_max = max(33,y_maxview);
//codeline is used to position messages
//'inputsection' lines down after the last line of the matrix
int codeline = x_viewsize+inputsection;

//Actual boundaries of the table
//These bounderies define the square in which values have been entered
int x_bound=0;
int y_bound=0;

//v_matrix is the visualisation matrix
vector v_matrix;
//mat is the actual matrix in which computing is done...
fmatrix mat(x_max,y_max);

//formulas records the different Lisp expressions
mapss formulas;
mapss regularformulas;
mapss referenceformulas;
map functions;

//the line 0 and the column 0 are used to display coordinates...
int i = 1;
int j = 1;
int I, J;
//Since, the matrix might be larger than the viewport,
//we need to record the offsets to position 0,0
int off_x = 0;
int off_y = 0;
bool modifying = false;
//----------------------------------------------------------------------

//inputs is used to handle modifications on: filenames and size.
//If you want to enrich tamgucalc, you might add a new key
mapss inputs;
string inputkey;
string inputvalue;

inputs["Size"] = ""+(x_viewsize-1)+":"+(y_viewsize-1);
inputs["Go"] = "1,1";
inputs["Column"] = columnsize;

string option;
//exploring the arguments:
//possible values are: -i, -n, -b and a filename
for (string e in _args) {
    if (_args[e] == "-h") {
        _sys.showcursor(true);
        println();
        println("-i: hide the indexes / -n: hide the messages / -b: black screen mode / file");
        println();
        _exit();
    }
    if (_args[e] == "-i") {
        displayindexes = false;
    }
    elif (_args[e] == "-n") {
        displayingmessage  = false;
        _sys.showcursor(false);
    }
    elif (_args[e] == "-b") {
        chooseblack = true;
    }
    else {
        option = e;
    }
}

inputs["File"] = option;
if (option != "")
    inputs["Data"] = option+".csv";
else
    inputs["Data"] = "";


//----------------------------------------------------------------------
//      Resizing Event
//----------------------------------------------------------------------
bool resized = true;
function resizing(int r, int c) {
    //We only resize, if no manual resizing has been done
    if (!resized)
        return;
    
    x_viewsize = r - inputsection;
    y_viewsize = c / columnsize;
    codeline = x_viewsize + inputsection;

    x_maxview = x_viewsize;
    y_maxview = y_viewsize;
    //These two values define the actual matrix size, which is different from viewsize
    //If the view port is larger than 101 and 51, then the matrix is equal to the viewport
    _sys.cls();
    displayall(off_x, off_y);
    showelement(i, j, off_x, off_y);
}

if (version() >= "Tamgu 1.2020.07.14.11") {
    //This for the case people are still using an old version of Tamgu
    //that does not provide resizing
    _eval("_sys.resizecallback(resizing);");
}

//----------------------------------------------------------------------
//      PREDEFINED METHODS (You can add your own here)
//      You can use loadin as well: loadin(pathname)
//      To load your own functions from an external file
//----------------------------------------------------------------------
//A few predefined methods
//IMPORTANT: When you define Lisp Functions in regular code
//The first "(" must be preceded with a "\"
\(defun average (x) (/ (sum x) (size x)))

\(defun standard_deviation(x)
    (setq avg (average x))
    (sqrt (/
            (sum
                (_map (lambda (x)
                        (* (- x avg) (- x avg)))
                    x)
            )
            (size x)
        )
    )
)
//Same with taskell syntax...
function std_var(fvector v) {
    float avg = v.sum()/v.size();
    return <sqrt </ <sum . map (\x->(x-avg)*(x-avg)) v> <size v>>>;
}

//You can call a regular function from a Lisp formula:
// (fillcolumn mat[:2][1:6] 1 10): fill column 10, starting at row 1 with values from mat[:2][1:6]
//fill a row with values, column c is fixed, it defines the starting point
function fillcolumn(vector v, int r, int c) {
    int vi = 0;
    r = max(1,r);
    c = max(1,c);
    r = min(r,x_max);
    c = min(c,y_max);
    for (int i in <r, r+v.size()>) {
        v_matrix[i][c] = v[vi];
        dispscreen(i, c, off_x, off_y);
        mat[i][c] = float(v[vi]);
        vi++;
    }
    return ("C"+r+","+c);
}

//fill a column with values, row r is fixed, it defines the starting point
function fillrow(vector v, int r, int c) {
    int vi = 0;
    r = max(1,r);
    c = max(1,c);
    r = min(r,x_max);
    c = min(c,y_max);
    for (int i in <c, c+v.size()>) {
        v_matrix[r][i] = v[vi];
        dispscreen(r, i, off_x, off_y);
        mat[r][i] = float(v[vi]);
        vi++;
    }
    return ("R"+r+","+c);
}

//Return all values up to a certain value: (from m[:1] 0)
function upto(fvector v, float val) {
    int vi = val in v;
    if (vi == -1)
        return [];
    //If the value is not found, the list is empty...
    return (v[:vi]);
}

//------------------------------------------------------------------
//This function is used to replace specific labels with their UTF8 symbol
function compactstring(string s, int p) {
    if (s[p-7:p] == "lambda ")
        s[p-7:p] = "λ ";
    elif (s[p-5:p] == "sqrt ")
        s[p-5:p] = "√ ";
    elif (s[p-5:p] == "cbrt ")
        s[p-5:p] = "∛ ";
    elif (s[p-4:p] == "_pi ")
        s[p-4:p] = "π ";
    elif (s[p-5:p] == "_tau ")
        s[p-5:p] = "τ ";
    elif (s[p-5:p] == "_phi ")
        s[p-5:p] = "φ ";
    elif (s[p-3:p] == "_e ")
        s[p-3:p] = "ℯ ";
    elif (s[p-2:p] == "/ ")
        s[p-2:p] = "÷ ";
    elif (s[p-4:p] == "**2 ")
        s[p-4:p] = "²";
    elif (s[p-4:p] == "**3 ")
        s[p-4:p] = "³";
    elif (s[p-3:p] == "** ")
        s[p-3:p] = "**";
    elif (s[p-2:p] == "* ")
        s[p-2:p] = "× ";
    elif (s[p-4:p] =="^^2 ")
        s[p-4:p] = "²";
    elif (s[p-4:p] =="^^3 ")
        s[p-4:p] = "³";
    return s;
}

function formulacolor() {
    if (chooseblack)
        _sys.colors(0,33,40);
    else
        _sys.colors(0,39,47);
}

function indexcolor() {
    if (chooseblack)
        _sys.colors(1,36,40);
    else
        _sys.colors(7,96,40);
}

function selectioncolor() {
    if (chooseblack)
        _sys.colors(1,31,40);
    else
        _sys.colors(7,31,49);
}

function defuncolor() {
    if (chooseblack)
        _sys.colors(1,92,49);
    else
        _sys.colors(7,94,107);
}

function stringcolor() {
    if (chooseblack)
        _sys.colors(1,92,49);
    else
        _sys.colors(0,94,49);
}
function normalcolor() {
    _sys.colors(0,0,0);
}

//initialisation of v_matrix
function initialisation() {
    int i,j;
    for (i in <x_max>) {
        v_matrix[i] = [];
        for (j in <y_max>) {
            mat[i:j] = 0;
            if (!i) {
                v_matrix[i].push(string(j));
            }
            elif (!j) {
                v_matrix[i].push(string(i));
            }
            else {
                v_matrix[i].push(defaultvalue);
            }
        }
    }
}

//Loading a file
function readtable(string f) {
    resized = true;
    int i,j;
    for (i in <1,x_max>) {
        for (j in <1,y_max>) {
            v_matrix[i][j] = defaultvalue;
            mat[i:j] = 0;
        }
    }

    try {
        svector sv;
        svector cut;
        int nb,xm, ym;
        string s,k,e;
        sv.read(f);
        bool beg = true;
        i=0;
        float val;
        for (s in sv) {
            cut=s.split("\t");
            if (beg == true) {
                //we have stored some parameters in the three first cells
                x_viewsize = cut[0];
                y_viewsize = cut[1];
                columnsize = cut[2];
                xm = cut[3];
                ym = cut[4];
                if (xm != x_max or ym != y_max)
                    resized = false;
                x_max = xm;
                y_max = ym;
                x_bound = cut[5];
                y_bound = cut[6];
                inputs["Size"] = ""+(x_viewsize-1)+":"+(y_viewsize-1);
                inputs["Column"] = columnsize;
                codeline = x_viewsize+inputsection;
                mat.dimension(x_max,y_max);
                beg=false;
                //we need to reset them
                cut[0] = '0';
                cut[1] = '1';
                cut[2] = '2';
                cut[3] = '3';
                cut[4] = '4';
                cut[5] = '5';
                cut[6] = '6';
            }
            j = 0;
            for (e in cut) {
                e=e.trim();
                if (e[0] == "(") {
                    k = i+"_"+j;
                    formulas[k] = e;
                    v_matrix[i][j] = defaultvalue;
                    mat[i:j] = 0;
                }
                elif (e[0] == '=' and e[-1] == ";") {
                    k = i+"_"+j;
                    regularformulas[k] = e;
                    v_matrix[i][j] = defaultvalue;
                    mat[i:j] = 0;
                }
                else {
                    v_matrix[i][j] = e;
                    if (isdigit(e[0]) or e[0]=='-') {
                        val = e;
                        mat[i:j] = val;
                    }
                }
                j++;
            }
            i++;
        }
        displayall(0,0);
        evaluation(0,0);
    }
    catch {
        initialisation();
        displayall(0,0);
    }
}

//Writing the visual matrix content to a file
function writetable(string f) {
    if (f=="") {
        displaymessage("Abort");
        return;
    }
    string k;
    int x_bound = x_bound;
    int y_bound=max(y_bound,7);
    displaymessage("Writing: "+f);
    file sv(f,"w");
    int i,j;
    string w;
    v_matrix[0][0] = string(x_viewsize);
    v_matrix[0][1] = string(y_viewsize);
    v_matrix[0][2] = string(columnsize);
    v_matrix[0][3] = string(x_max);
    v_matrix[0][4] = string(y_max);
    v_matrix[0][5] = string(x_bound);
    v_matrix[0][6] = string(y_bound);

    for (i in <x_bound>) {
        for (j in <y_bound>) {
            if (j)
                sv.write("\t");
            k = i+"_"+j;
            if (formulas.test(k))
                sv.write(formulas[k]);
            elif (regularformulas.test(k))
                sv.write(regularformulas[k]);
            else {
                w = v_matrix[i][j];
                sv.write(w.trim());
            }
        }
        sv.write("\n");
    }
    v_matrix[0][0] = "0";
    v_matrix[0][1] = "1";
    v_matrix[0][2] = "2";
    v_matrix[0][3] = "3";
    v_matrix[0][4] = "4";
    v_matrix[0][5] = "5";
    v_matrix[0][6] = "6";
}

//Writing only data to a CSV file. The result of formulas is stored
function writecsv(string f) {
    if (f=="") {
        displaymessage("Abort");
        return;
    }
    if ('.csv' not in f)
        f+=".csv";
    displaymessage("Writing (csv): "+f);
    file sv(f,"w");
    int i,j;
    string cell;
    for (i in <1,x_bound>) {
        for (j in <1,y_bound>) {
            if (j!=1)
                sv.write("\t");
            cell = v_matrix[i][j].trim();
            if (cell[-1] == '!')
                cell=cell[:-1];
            if (!cell[0].isdigit() and cell[0] != '-') {
                if (cell[0] == "'")
                    cell=cell[1:];
                sv.write(cell.json());
            }
            else
                sv.write(cell);
        }
        sv.write("\n");
    }
}


//------------------- The Code ---------
function replacewithfloat(string str) {
    ivector iv = r"%d+(.%d+(e({-+})%d+))" in str;
    string s;
    int b,e;
    for (int i in <iv.size()-1,0,-2>) {
        b = iv[i-1];
        e = iv[i];
        s = str[b:e];
        if ("." in s)
            continue;

        if (str[e] in " );" and not str[b-1].isalpha()) {
            str[b:e] = s+".0";
        }
    }
    return str;
}

function evaluation(int off_x, int off_y) {
    if (formulas.size()==0)
        return;

    string ky;
    int i,j;
    msgerr="";
    string msg;
    self val;
    float value;
    bool stop=false;
    string recompiled;
    string cell;
    svector coord;
    int r;

    //We record functions beforehand
    for (ky in formulas) {
        cell = formulas[ky];
        try {
            i = ky[:"_"][:-1];
            j = ky["_":][1:];
            if (referenceformulas[ky] != cell) {
                recompiled = "Recompiled: "+ky;
                referenceformulas[ky] = cell;
                //We only reaevaluate a function, if it has been modified
                if ("defun " in cell) {
                    v_matrix[i][j] = "#"+cell[" ":"("][:-1].trim();
                    mat[i][j] = 0;
                    lisp_interpreter.eval(cell);
                }
                else {
                    //We create a function on the fly, to avoid recompiling again and again
                    //the code...
                    //We have replaced lambda with λ for compactness reason, we need to
                    //replace it back to compile it...
                    cell = cell.replace("λ","lambda");
                    cell = replacewithfloat(cell);
                    cell = "(defun F_"+ky+"() " + cell+")";
                    //this is a piece of code for intervals, where
                    //the the final index should be one more...
                    coord = r"%[?+%]%[%d+:%d+%]" in cell;
                    for (string c in coord) {
                        r = 1+c[-r":%d+"][1:];
                        cell[c] = c[:-":"]+r+"]";
                    }
                    functions[ky] = lisp_interpreter.eval(cell);
                }
            }
        }
        catch(msg) {
            msgerr=msg;
            //We do not engage then in computing
            ky["_"] = ",";
            if ("at line" in msgerr)
                msgerr[" at line":] = "at cell: "+ky;
            else
                msgerr += " at cell: "+ky;
            v_matrix[i][j] = "#FCERR";
            mat[i][j] = 0;
            dispscreen(i, j, off_x, off_y);
        }
    }
    int loop;
    string fnct;
    call Fnct;
    int mx = max(regularformulas.size(), formulas.size());
    //The top loop is due to the interdependencies between the formulas
    while (!stop) {
        //If we cannot get out of the main loop, it means trouble...
        //One of the formulas is in cross-dependency with another...
        //F1 needs F2 to compute and F2 needs also F1... stalemate...
        if (loop > mx)
            break;

        stop=true;
        loop++;
        for (ky in regularformulas) {
            try {
                //We remove the "=" and the ";"
                cell=regularformulas[ky].trim();
                i = ky[:"_"][:-1];
                j = ky["_":][1:];
                if (cell[0] == '=' and cell[-1] == ';') {
                    cell=cell[1:-1];
                    //this is a piece of code for intervals, where
                    //the the final index should be one more...
                    coord = r"%[?+%]%[%d+:%d+%]" in cell;
                    for (string c in coord) {
                        r = 1+c[-r":%d+"][1:];
                        cell[c] = c[:-":"]+r+"]";
                    }
                    cell = replacewithfloat(cell);
                    val = _eval(cell);
                    if (val.float() != mat[i:j])
                        stop = false;
                    mat[i:j] = val.float();
                    v_matrix[i][j] = val.string();
                    v_matrix[i][j]+=";";
                    dispscreen(i, j, off_x, off_y);
                }
                else {
                    msgerr=msg;
                    ky["_"] = ",";
                    msgerr += "Incomplete formula at cell: "+ky;
                    v_matrix[i][j] = "#ERR;";
                    mat[i][j] = 0;
                    dispscreen(i, j, off_x, off_y);
                }
            }
            catch(msg) {
                msgerr=msg;
                ky["_"] = ",";
                if ("at line" in msgerr)
                    msgerr[" at line":] = "at cell: "+ky;
                else
                    msgerr += " at cell: "+ky;
                v_matrix[i][j] = "#ERR;";
                mat[i][j] = 0;
                dispscreen(i, j, off_x, off_y);
            }
        }

        for (ky in formulas) {
            //functions are skipped
            if ("defun " in formulas[ky])
                continue;

            //We have recorded formulas as function: F_row_col
            cell="(F_"+ky+")";
            //We extract the cell position, where the formula is stored
            i = ky[:"_"][:-1];
            j = ky["_":][1:];

            try {
                Fnct = functions[ky];
                val = Fnct();
                if (val.float() != mat[i:j])
                    stop = false;
                mat[i:j] = val.float();
                v_matrix[i][j] = val.string();
                v_matrix[i][j]+="!";
                dispscreen(i, j, off_x, off_y);
            }
            catch(msg) {
                msgerr=msg;
                ky["_"] = ",";
                if ("at line" in msgerr)
                    msgerr[" at line":] = "at cell: "+ky;
                else
                    msgerr += " at cell: "+ky;
                v_matrix[i][j] = "#ERR";
                mat[i][j] = 0;
                dispscreen(i, j, off_x, off_y);
            }
        }
    }
    cell="";
    //displayall(off_x, off_y);
    if (recompiled != "") {
        if (msgerr != "")
            msgerr += " "+recompiled;
        else
            msgerr = recompiled;
    }
    if (msgerr)
        displayerr(msgerr);
}

//Display methods
//Display one element, we check its size
function dispelementregular(int i,int j, int off_x, int off_y) {
    string u = v_matrix[i+off_x][j+off_y];
    if (u[0] == "'") {
        print(u);
        return;
    }
    if (u.size() >= columnsize-1)
        u=u[:columnsize-2]+"_";
    print(u);
}

function dispelement(int i,int j, int off_x, int off_y) {
    string u = v_matrix[i+off_x][j+off_y];
    if (u[0] == "'") {
        print(u);
        return;
    }
    if (u[-1] == "!" or u[-1] == ';')
        formulacolor();
    elif (u[0] == "#")
        defuncolor();
    elif (!u[0].isdigit() && u[0] != "-" && u != defaultvalue)
        stringcolor();

    if (u.size() >= columnsize-1)
        u=u[:columnsize-2]+"_";
    print(u);
    normalcolor();
}

//Disply the element if it is on screen
function dispscreen(int x, int y, int off_x, int off_y) {
    if (x <= off_x or x >= (x_viewsize + off_x) or y <= off_y or y >= (y_viewsize + off_y))
        return;
    //We are in the viewport, we can display...
    _sys.row_column(x - off_x + 1, (y - off_y)*columnsize);
    string u = v_matrix[x][y];
    if (u[0] == "'") {
        print(u);
        return;
    }
    if (u[-1] == "!" or u[-1] == ';')
        formulacolor();
    elif(u[0] == "#")
        defuncolor();
    elif(!u[0].isdigit() && u[0] != "-" && u != defaultvalue)
        stringcolor();

    if (u.size() >= columnsize - 1)
        u = u[:columnsize - 2] + "_";
    print(u);
    normalcolor();
    int lg = columnsize-u.size()-1;
    if (lg > 0) {
        u="";
        u.padding(lg, " ");
        print(u);
    }
}

function clearelement(int i, int j,int off_x, int off_y) {
    _sys.row_column(i+1,columnsize*j);
    string u = v_matrix[i+off_x][j+off_y];
    if (u[0] == "'") {
        print(u);
        return;
    }
    if (u[-1] == "!" or u[-1] == ';')
        formulacolor();
    elif (u[0] == "#")
        defuncolor();
    elif (!u[0].isdigit() && u[0] != "-" && u != defaultvalue)
        stringcolor();

    if (u.size() >= columnsize-1)
        u=u[:columnsize-2]+"_";
    print(u);
    normalcolor();
}

function displayline(int off_x, int off_y, int row) {
    if (displayindexes) {
        _sys.row_column(row+1,1);
        indexcolor();
        dispelementregular(row,0, off_x, 0);
        normalcolor();
    }
    for (int jcol in <1,y_viewsize>) {
        _sys.row_column(row+1,columnsize*jcol);
        dispelement(row,jcol, off_x, off_y);
    }
}

//Displaying all elements on screen
function displayall(int off_x, int off_y) {
    int i,j;
    _sys.cls();
    if (displayindexes) {
        indexcolor();
        //display column numbers
        for (i in <x_viewsize>) {
            _sys.row_column(i+1,1);
            dispelementregular(i,0,off_x,0);
        }

        //display line numbers
        for (j in <y_viewsize>) {
            _sys.row_column(1,columnsize*j);
            dispelementregular(0,j,0,off_y);
        }

        _sys.row_column(1,1);
        print("T");
        normalcolor();
        print("  ");
    }
    for (i in <1,x_viewsize>) {
        for (j in <1,y_viewsize>) {
            _sys.row_column(i+1,columnsize*j);
            dispelement(i,j, off_x, off_y);
        }
    }
}

function clearzonemessage() {
    _sys.row_column(codeline-5,0);
    _sys.eraseline(2);
    _sys.row_column(codeline-4,0);
    _sys.eraseline(2);
    _sys.row_column(codeline-3,0);
    _sys.eraseline(2);
    _sys.row_column(codeline-2,0);
    _sys.eraseline(2);
    _sys.row_column(codeline-1,0);
    _sys.eraseline(2);
    _sys.row_column(codeline,0);
    _sys.eraseline(2);
}

//Error message is displayed on line 4
function displayerr(string s) {
    clearzonemessage();
    if (displayingmessage) {
        _sys.row_column(codeline-4,0);
        print(s);
    }
    else
        _sys.row_column(1,1);
}

//Messages are displayed on line 3
function displaymessage(string s) {
    clearzonemessage();
    if (displayingmessage) {
        _sys.row_column(codeline-3,0);
        print(s);
    }
    else
        _sys.row_column(1,1);
}

function displayhelp(string s) {
    clearzonemessage();
    _sys.row_column(codeline-4,0);
    print(s);
}

function displayprompt(string s) {
    if (displayingmessage) {
        _sys.row_column(codeline-1,0);
        _sys.eraseline(2);
        print(s);
    }
    else
        _sys.row_column(1,1);
}

function pureselection(int i, int j, int off_x, int off_y) {
    _sys.row_column(i+1,columnsize*j);
    //We use a specific color to show that it has been selected
    selectioncolor();
    dispelementregular(i,j, off_x, off_y);
    //Colors are reset, we then display on the last line the current value
    normalcolor();
}

//Highlight the current element
function showelement(int i, int j, int off_x, int off_y) {
    //We check if we are in a formula mode
    int I = i+off_x;
    int J = j+off_y;
    string display = I+","+J+" "+inputkey+": "+inputvalue;

    //we use spaces to clean the cell first
    int lg = columnsize - v_matrix[I][J].size()-1;
    //Then we position our cursor again to display our value
    _sys.row_column(i+1,columnsize*j);
    //We use a specific color to show that it has been selected
    selectioncolor();
    dispelementregular(i,j, off_x, off_y);
    //Colors are reset, we then display on the last line the current value
    normalcolor();
    if (lg > 0) {
        string space;
        space.padding(lg, " ");
        print(space);
    }

    displayprompt(display);
}

//----------------------------------------------------------------------------------------------------
//MAIN LOOP

//If a filename is provided, we try to read the file, otherwise we initialise our structure
initialisation();
if (inputs["File"]=="")
    displayall(0,0);
else
    readtable(inputs["File"]);

string msgform="%1Arrows%2 select / %1Enter%2 to add cell / %1..%2 or %1: %2 define range / %1Balance parentheses%2 to exit;";
msgform=msgform.format(colorsel,colornrm);
string helpmsg = @"%1Ctrl-s%2: Save / %1Ctrl-w%2: Save as / %1Ctrl-f%2: Save Data / %1Ctrl-l%2: Load / %1Ctrl-g%2: Goto
%1Ctrl-r%2: Grid Size / %1Ctrl-t%2: Column Size / %1Ctrl-d%2: Delete / %1Ctrl-k%2: Copy / %1Ctrl-x%2: Move
%1Ctrl-i%2: Hide Indexes / %1Ctrl-n%2: Hide Message

%1_pi%2: π / %1_tau%2: τ / %1_phi%2: φ / %1_e%2: ℯ / %1sum%2 / %1product%2 / %1(..)%2: Lisp formula / %1=..;%2: regular formula"@;

helpmsg = helpmsg.format(colorsel,colornrm);
string msgbase = "%1Ctrl-u%2: Help / %1Ctrl-e%2: Edit / %1Ctrl-b%2: Black Mode /  %1Ctrl-q%2: Quit";
msgbase =  msgbase.format(colorsel,colornrm);
displaymessage(msgbase);

string msgedit = "%1Edit Mode%2... %1Esc%2=abort / %1Enter%2=record";
msgedit =  msgedit.format(colorsel,colornrm);

//Triggering mouse action
//The _sys.reset() deactivates mouse action
_sys.inmouse();

int posinstring;
string dsp;
int firstclickx, firstclicky;
int lastselx,lastsely;
bool tracking=false;
i = 1;
j = 1;
string ky = i+"_"+j;
string backup;
int formi, formj, sz;
bool buildingformula=false;
bool field = false;
bool isselected = false;

string currentkey;
string currentvalue;
string s;


function handlingarrows(string s) {
    int bi = i;
    int bj = j;

    //this is the section for editing values on prompt line
    if (modifying) {
        if (s == _sys_keyright)
            posinstring++;
        elif (s == _sys_keyleft)
            posinstring--;
        else
            return false;

        if (posinstring > inputvalue.size()+1)
            posinstring = inputvalue.size()+1;
        if (posinstring <= 0)
            posinstring = 1;
        return true;
    }

    int ei = i;
    int ej = j;

    if (s == _sys_keyright)
        j++;
    elif (s == _sys_keyleft)
        j--;
    elif (s == _sys_keyup)
        i--;
    elif (s == _sys_keydown)
        i++;
    else
        return false;

    //moving the cursor in the grid
    //We clear the selection for the current element
    clearelement(ei, ej, off_x, off_y);

    bool redisplay=false;
    int scroll=0;
    if (i < 1) {
        i=1;
        if (off_x > 0) {
            off_x--;
            scroll=-1;
        }
    }
    else {
        if (i >= x_viewsize) {
            i = x_viewsize-1;
            if ((off_x+i) < x_max-1) {
                off_x++;
                scroll=1;
            }
        }
    }
    if (j < 1) {
        j = 1;
        if (off_y > 0) {
            off_y--;
            redisplay=true;
        }
    }
    else {
        if (j >= y_viewsize) {
            j = y_viewsize-1;
            if ((off_y+j) < y_max-1) {
                off_y++;
                redisplay=true;
            }
        }
    }
    if (redisplay)
        displayall(off_x, off_y);
    if (scroll) {
        //We do not want to scroll the top line...
        _sys.scrollmargin(2, codeline-inputsection);
        if (scroll==1) {
            _sys.scroll_up(1);
        }
        else
            _sys.scroll_down(1);

        //First we reset the scrolling area
        _sys.scrollmargin(1,coords[1]);
        //We need to display the missing line
        displayline(off_x, off_y, i);
        //We then clean the scrolling buffer
        _sys.clearscreen(3);
    }
    return true;
}

function mousecontrol(string s) {
    ivector xymouse;
    xymouse = _sys.mousedown1(s);
    if (xymouse != []) {
        if (tracking) {
            fullselection(firstclickx,firstclicky,lastselx,lastsely,false);
            tracking=false;
        }

        //We check if we are editing a formula or a value
        if (xymouse[0] == codeline-1) {
            if (!modifying) {
                modifying = true;
                initvalue();
            }
            posinstring = xymouse[1]-dsp.size();
            if (posinstring > inputvalue.size()+1)
                posinstring = inputvalue.size()+1;
            if (posinstring <= 0)
                posinstring = 1;
            return true;
        }

        clearelement(i,j, off_x, off_y);
        if (xymouse[0] > 1) {
            if (xymouse[1] < columnsize)
                xymouse[1] = columnsize;
            i = xymouse[0]-1;
            j = xymouse[1]/columnsize;
            
            if (i >= x_viewsize)
                i = x_viewsize - 1;
            if (j >= y_viewsize)
                j = y_viewsize - 1;

            //this section allows for a tracking preparation
            //if tracking should occur
            firstclickx = i;
            firstclicky = j;
            lastselx = firstclickx;
            lastsely = firstclicky;
            //Again we clear the currrent element, while moving the cursor around
            clearelement(i,j, off_x, off_y);
            modifying = false;
            return true;
        }
        return false;
    }

    //if the mouse is up, then no tracking has taken place
    xymouse = _sys.mouseup(s);
    if (xymouse != []) {
        if (buildingformula) {
            initcoords();
            clearelement(i, j, off_x, off_y);
            inputvalue = inputvalue.trim()+" mat["+I+":"+J+"] ";
            currentvalue = inputvalue;
            i = formi - off_x;
            j = formj - off_y;
            initcoords();
        }
        return true;
    }

    //Tracking the mouse position
    xymouse = _sys.mousetrack(s);
    while (xymouse != []) {
        if (xymouse[0] > 1) {
            if (xymouse[1] < columnsize)
                xymouse[1] = columnsize;
            //We deselect the previous selection
            fullselection(firstclickx,firstclicky,lastselx,lastsely,false);
            lastselx = xymouse[0]-1;
            lastsely = xymouse[1]/columnsize;
            //We reselect it
            fullselection(firstclickx,firstclicky,lastselx,lastsely,true);
        }
        s = _sys.getchar();
        xymouse = _sys.mouseup(s);
        if (xymouse != []) {
            tracking = true;
            return true;
        }
        xymouse = _sys.mousetrack(s);
    }

    //Scrolling section... We can only scroll up or down
    xymouse = _sys.mousescrollup(s);
    if (xymouse != []) {
        i = 1;
        I = i+off_x;
        handlingarrows(_sys_keyup);
        return !tracking;
    }
    xymouse = _sys.mousescrolldown(s);
    if (xymouse != []) {
        i = x_viewsize-1;
        I = i+off_x;
        handlingarrows(_sys_keydown);
        return !tracking;
    }
    return false;
}

function initcoords() {
    I = i+off_x;
    J = j+off_y;
    //ky is a key to access formulas...
    ky = I+"_"+J;
}

function initvalue() {
    //i,j are the position of the current cell on screen
    //I,J are the position of the current cell in the acual matrix
    //off_x, off_y are the offsets that records which part of the matrix is actually displayed
    I = i+off_x;
    J = j+off_y;
    //ky is a key to access formulas...
    ky = I+"_"+J;
    //the Lisp formulas, starting with a (
    if (formulas.test(ky)) {
        inputkey = "formula";
        inputvalue = formulas[ky];
    }//the simple formulas introduced with a "=" and finished with a ";"
    elif (regularformulas.test(ky)) {
        inputkey = "regular";
        inputvalue = regularformulas[ky];
    }
    else {//a regular value
        inputkey = "value";
        inputvalue = v_matrix[I][J];
        if (inputvalue == defaultvalue)
            inputvalue = "";
    }
    backup = inputvalue;
    dsp = I+","+J+" "+inputkey+": ";
}

function updatevalue() {
    if (colorparenth in inputvalue) {
        inputvalue = inputvalue.replace(colorparenth,"");
        inputvalue = inputvalue.replace(colornrm,"");
    }

    x_bound = max(x_bound,I+1);
    y_bound = max(y_bound,J+1);
    if (inputkey == "formula") {
        if (inputvalue == "") {
            formulas.pop(ky);
            inputkey = "value";
            v_matrix[I][J] = defaultvalue;
            mat[I:J] = 0;
        }
        else
            formulas[ky] = inputvalue;
    }
    elif (inputkey == "regular") {
        if (inputvalue == "") {
            regularformulas.pop(ky);
            inputkey = "value";
            v_matrix[I][J] = defaultvalue;
            mat[I:J] = 0;
        }
        else
            regularformulas[ky] = inputvalue;
    }
    elif (inputkey == "value") {
        if (inputvalue=="") {
            v_matrix[I][J] = defaultvalue;
            mat[I:J] = 0;
        }
        else {
            v_matrix[I][J] = inputvalue;
            mat[I][J] = inputvalue.float();
        }
    }
}

//We check if the inputvalue is actually a formula, that was modified from
//a non formula
function checkformula() {
    if (colorparenth in inputvalue) {
        inputvalue = inputvalue.replace(colorparenth,"");
        inputvalue = inputvalue.replace(colornrm,"");
    }

    x_bound = max(x_bound,I+1);
    y_bound = max(y_bound,J+1);
    currentvalue = inputvalue.trim();
    if (currentvalue[0] == "(" and currentvalue.count("(") == currentvalue.count(")")) {
        //We reinstate it as a formula
        formulas[ky] = currentvalue;
        evaluation(off_x,off_y);
        return true;
    }
    elif (currentvalue[0] == "=" and currentvalue[-1]==";") {
        regularformulas[ky] = currentvalue;
        evaluation(off_x,off_y);
        return true;
    }
    return false;
}

//We create a cell range matrix access from coordinates in the grid
function makerange(int lasti, int lastj, int I, int J) {
    if (lasti > I)
        [lasti,I] = [I,lasti];
    if (lastj > J)
        [lastj,J] = [J,lastj];
    string frm;
    //a single line
    if (lasti == I) {
        frm = "mat["+I+":]["+lastj+":"+J+"]";
    }
    elif (lastj == J) { //a single column
        frm = "mat[:"+J+"]["+lasti+":"+I+"]";
    }
    else { //a square
        int n = lasti;
        //&&& is the merge operator
        frm = "(&&& ";
        bool beg=true;
        //we will add several lines together
        while (n <= I) {
            if (!beg)
                frm += " ";
            else
                beg=false;
            frm += "mat["+n+":]["+lastj+":"+J+"]";
            n++;
        }
        frm += ")";
    }
    return frm;
}

//this is called when the cursor is moved with arrows and the user
//has typed: .. or :
function createrange() {
    if (inputvalue.trim()[-1] == ":" or inputvalue.trim()[-2:] == "..") {
        //We are extending a zone of selection
        string frm = inputvalue[-"mat":];
        svector coords = r"%d+" in frm;
        if (coords.size() == 2) {
            int lasti = coords[0];
            int lastj = coords[1];
            frm = makerange(lasti,lastj, I, J);
            inputvalue[-"mat":] = frm;
            selection(lasti, lastj, true);
            isselected=true;
            return true;
        }
    }
    return false;
}

//Jumping to a specific cell in the matrix
function gotocell() {
    int pi = inputvalue[:","][:-1];
    int pj = inputvalue[",":][1:];
    pi = max(1,pi);
    pj = max(1,pj);
    pi = min(x_max-1,pi);
    pj = min(y_max-1,pj);
    off_x = max(off_x+pi-I,0);
    off_y = max(off_y+pj-J,0);
    I = pi;
    J = pj;
    i = I-off_x;
    j = J-off_y;
    displayall(off_x,off_y);
    initvalue();
}

//resizing the grid view port
function resizing() {
    ivector iv = inputvalue.split(":");
    if (iv == 2) {
        int x = iv[0];
        int y = iv[1];
        x++;
        y++;
        if (x > x_maxview) {
            x = x_maxview;
        }
        else {
            if (x <= 1) {
                x = 2;
            }
        }
        if (y > y_maxview) {
            y = y_maxview;
        }
        else {
            if (y <= 1) {
                y = 2;
            }
        }
        x_viewsize = x;
        y_viewsize = y;
        inputs[inputkey] = ""+(x_viewsize-1)+":"+(y_viewsize-1);
        codeline = x_viewsize+inputsection;
        i = 1;
        I = off_x+1;
        j = 1;
        J = off_y+1;
        displayall(off_x, off_y);
    }
}

//deletion of a cell selection
function deletion(int formi, int formj, int I, int J) {
    if (formi > I)
        [formi,I] = [I,formi];
    if (formj > J)
        [formj,J] = [J,formj];
    int e;
    string k;
    while (formi <= I) {
        e = formj;
        while (e <= J) {
            k = formi+"_"+e;
            if (formulas.test(k))
                formulas.pop(k);
            elif (regularformulas.test(k))
                regularformulas.pop(k);
            v_matrix[formi][e] = defaultvalue;
            mat[formi:e] = 0;
            dispscreen(formi, e, off_x, off_y);
            e++;
        }
        formi++;
    }
    evaluation(off_x,off_y);
    resetbuildingformula();
    initvalue();
}

function selection(int ei, int e, bool v) {
    ei = max(ei, 1);
    e = max(e, 1);
    if (ei > I)
        [ei,I] = [I,ei];
    if (e > J)
        [e,J] = [J,e];

    int ej;
    string k;
    while (ei <= I) {
        ej = e;
        while (ej <= J) {
            if (v)
                showelement(ei,ej, off_x, off_y);
            else
                clearelement(ei,ej,off_x, off_y);
            ej++;
        }
        ei++;
    }
}

//selection on screen of a full range of cells
function fullselection(int ei, int e, int I, int J, bool v) {
    if (ei > I) {
        [ei,I] = [I,ei];
    }
    if (e > J) {
        [e,J] = [J,e];
    }

    int ej;
    string k;
    while (ei <= I) {
        ej = e;
        while (ej <= J) {
            if (v)
                pureselection(ei,ej, off_x, off_y);
            else
                clearelement(ei,ej,off_x, off_y);
            ej++;
        }
        ei++;
    }
}

//this function is used to clean a group of cells that was moved to another position
function deletefrominputvalue() {
    svector v = r"%d+" in inputvalue;
    int ci = v[0];
    int cj = v[1];
    int lasti = v[2];
    int lastj = v[3];
    deletion(ci,cj,lasti,lastj);
}

//We update the internal indexes according to the new position
function replaceforpaste(string s, string k, int di, int dj) {
    int ki = k[:"_"][:-1];
    int kj = k["_":][1:];
    string u, rl, rc;
    int i;

    //Updating column
    string sub = "mat[:"+kj+"]";
    ivector coord =  sub in s;
    for (i in coord) {
        u = s[i:i+sub.size()];
        rc = "mat[:"+dj+"]";
        s=s.replace(u,rc);
    }

    //Updating row
    sub = "mat["+ki+":]";
    coord = sub in s;
    for (i in coord) {
        u = s[i:i+sub.size()];
        rl = "mat["+di+":]";
        s=s.replace(u,rl);
    }

    //Updating one cell position: [x:y] according to new column
    treg tr1("mat%[%d+:"+kj+"%]");
    coord =  tr1 in s;
    for (i in <0,coord,2>) {
        u = s[coord[i]:coord[i+1]];
        rc = u[:":"]+dj+"]";
        s=s.replace(u,rc);
    }

    //Updating one cell position: [x:y] according to new row
    treg tr2("mat%["+ki+":%d+%]");
    coord =  tr2 in s;
    for (i in <0,coord,2>) {
        u = s[coord[i]:coord[i+1]];
        rl = "mat["+di+u[":":];
        s=s.replace(u,rl);
    }
    return s;
}

function pasting() {
    svector v = r"%d+" in inputvalue;
    int ci = v[0];
    int cj = v[1];
    int lasti = v[2];
    int lastj = v[3];
    int e;
    int di = I;
    int dj = J;
    string k, l, c, rl, rc, u;
    while (ci <= lasti) {
        e = cj;
        dj = J;
        while (e  <= lastj) {
            k = ci+"_"+e;
            //We update the indexes as well
            if (formulas.test(k) or regularformulas.test(k)) {
                bool regular = false;
                if (regularformulas.test(k))
                    regular = true;
                s = replaceforpaste(formulas[k],k, di, dj);
                if (di >= 1 and dj >= 1) {
                    k = di+"_"+dj;
                    if (regular)
                        regularformulas[k] = s;
                    else
                        formulas[k]=s;
                }
            }
            else {
                if (di >= 1 and dj >= 1) {
                    v_matrix[di][dj] = v_matrix[ci][e];
                    mat[di:dj] = mat[ci:e];
                    dispscreen(di, dj, off_x, off_y);
                }
            }
            dj++;
            e++;
        }
        di++;
        ci++;
    }
    evaluation(off_x,off_y);
}

//This function is called when a value was Copy/Paste from out of tamgucalc
function frompaste(string s) {
    s=s.trim();
    string u,k;
    //We try to detect from which place it was copied
    if (s[0] == '(') {
        for (k in formulas) {
            if (formulas[k].trim() == s) {
                u=k;
                break;
            }
        }
    }
    else {
        for (k in regularformulas) {
            if (regularformulas[k].trim() == s) {
                u=k;
                break;
            }
        }
    }

    if (u != "") {
        if (s[0] == '(')
            formulas[ky]=replaceforpaste(formulas[ky],u,I,J);
        else
            regularformulas[ky]=replaceforpaste(regularformulas[ky],u,I,J);
        evaluation(off_x,off_y);
        return true;
    }

    if (s[0] == '(') {
        inputkey = "formula";
        currentkey = inputkey;
        currentvalue += s;
        inputvalue += s;
        formi = I;
        formj = J;
        if (currentvalue.count("(") != currentvalue.count(")"))
            buildingformula = true;
        return true;
    }
    elif (s[0] == '=') {
        inputkey = "regular";
        currentkey = inputkey;
        currentvalue += s;
        inputvalue += s;
        formi = I;
        formj = J;
        if (currentvalue[-1] != ";")
            buildingformula = true;
        return true;
    }

    return false;
}

//Fields are actually the different values that can be modified in tamgucalc
//such as: pathname, grid size, column size, but also the different actions
//such as: copy, move or delete
function checkfield() {
    if (inputkey == "Delete") {
        //We display then we will delete
        inputkey = "Deletion";
        inputvalue = currentvalue + I+","+J;
        selection(formi, formj, true);
        isselected = true;
        s=initfield();
        return false;
    }

    if (inputkey == "Move") {
        //We display then we will delete
        inputkey = "Moving";
        inputvalue = currentvalue + I+","+J+" at ";
        currentvalue = inputvalue;
        selection(formi, formj, true);
        isselected = true;
        s=initfield();
        return false;
    }

    if (inputkey == "Copy") {
        //We display then we will delete
        inputkey = "Copying";
        inputvalue = currentvalue + I+","+J+" at ";
        currentvalue = inputvalue;
        selection(formi, formj, true);
        isselected = true;
        s=initfield();
        return false;
    }

    if (inputkey == "Moving") {
        pasting();
        deletefrominputvalue();
        resetbuildingformula();
    }
    elif (inputkey == "Copying") {
        //We display then we will delete
        resetbuildingformula();
        pasting();
    }
    elif (inputkey == "Deletion") {
        //actual deletion
        deletion(formi, formj, I, J);
    }
    elif (inputkey == "Go")
        gotocell();
    elif (inputkey == "Column") {
        columnsize = inputvalue;
        if (columnsize < 4 or columnsize >= 20)
            columnsize = 8;
        inputs[inputkey] = inputvalue;
        displayall(off_x, off_y);
        initvalue();
    }
    elif (inputkey == "Size") {
        resizing();
        initvalue();
    }
    elif (inputkey == "Data") {
        if (inputvalue != "") {
            inputs[inputkey] = inputvalue;
            writecsv(inputvalue);
        }
    }
    elif (inputkey=="File") {
        if (inputvalue != "") {
            inputs[inputkey] = inputvalue;
            writetable(inputvalue);
        }
    }
    elif (inputkey=="Load") {
        if (inputvalue != "") {
            inputs[inputkey] = inputvalue;
            readtable(inputvalue);
        }
    }
    return true;
}

//These are the variables that are used when creating a formula
function resetbuildingformula() {
    formi = 0;
    formj = 0;
    buildingformula = false;
    tracking=false;
}
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//                       MAIN LOOP
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------


initvalue();
showelement(i,j, off_x, off_y);
s=_sys.getchar();

function initfield() {
    dsp = I+","+J+" "+inputkey+": ";
    currentkey = inputkey;
    currentvalue = inputvalue;
    displayprompt(dsp+inputvalue);
    return _sys.getchar();
}

int kar;
float v;

//17 is ctrl-q
bool disphelp = false;
while (s[0].ord() != 17) {
    if (s == "") {
        s = _sys.getchar();
        continue;
    }

    if (disphelp) {
        displaymessage(msgbase);
        disphelp = false;
    }

    //We delete a full cell
    if (s == _sys_keydel) {
        if (modifying) {
            if (posinstring <= inputvalue.size())
                inputvalue = inputvalue[:posinstring-1]+inputvalue[posinstring:];

            displayprompt(dsp+inputvalue);
            _sys.row_column(codeline-1,dsp.size()+posinstring);
            s=_sys.getchar();
            continue;
        }

        //tracking: a number of cells have been selected with the mouse
        if (tracking) {
            //we delete them all
            deletion(firstclickx+off_x,firstclicky+off_y, lastselx+off_x, lastsely+off_y);
            tracking = false;
        }

        //otherwise, we only delete one cell
        inputvalue = "";
        updatevalue();
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    //if a ctrl-character has been pressed, it might corresponds to an action
    if (s.ord() >= 1 and s.ord() <= 24) {
        kar = s[0].ord();
        bool used=false;
        switch (kar) {
            1: {
                if (modifying) {
                    posinstring = 1;
                    used = true;
                    displayprompt(dsp+inputvalue);
                    _sys.row_column(codeline-1,dsp.size()+posinstring);
                }
            }
            2: {
                used = true;
                chooseblack = chooseblack.invert();
                displayall(off_x, off_y);
                showelement(i,j, off_x, off_y);
            }
            4: { //ctrl-d
                //Deleting a group of cells
                if (tracking) {
                    inputkey = "Deletion";
                    inputvalue="from: "+firstclickx+","+firstclicky+" up to "+lastselx+","+lastsely;
                    formi = firstclickx;
                    formj = firstclicky;
                    I = lastselx;
                    J = lastsely;
                    isselected = true;
                }
                else {
                    inputkey="Delete";
                    inputvalue="from: "+I+','+J+" up to ";
                    formi = I;
                    formj = J;
                }
                field = true;
                used = true;
            }
            5: {
                //Ctrl-e
                modifying=true;
                used = true;
                displaymessage("Modifying");
                posinstring = inputvalue.size()+1;
                backup = inputvalue;
                displayprompt(dsp+inputvalue);
                _sys.row_column(codeline-1,dsp.size()+posinstring);
            }
            6: {
                //ctrl-f
                inputkey="Data";
                used = true;
                inputvalue=inputs[inputkey];
                field = true;
                if (inputvalue == "" and inputs["File"] != "")
                    inputvalue = inputs["File"]+".csv";
            }
            7: { //ctrl-g
                inputkey = "Go";
                inputvalue = I+","+J;
                field = true;
                used = true;
            }
            9: {//ctrl-i (hide indexes
                displayindexes = displayindexes.invert();
                displayall(off_x, off_y);
                used = true;
                displaymessage(msgbase);
                showelement(i,j, off_x, off_y);
            }
            11: { //ctrl-k
                //Copying a group of cells
                if (tracking) {
                    inputkey = "Copying";
                    inputvalue="from: "+firstclickx+","+firstclicky+" up to "+lastselx+","+lastsely+" at ";
                    formi = firstclickx;
                    formj = firstclicky;
                    isselected = true;
                }
                else {
                    inputkey="Copy";
                    inputvalue="from: "+I+','+J+" up to ";
                    formi = I;
                    formj = J;
                }
                field = true;
                used = true;
            }
            12: {
                used = true;
                inputvalue=inputs["File"];
                field = true;
                inputkey="Load";
            }
            14: {//ctrl-n (hide message
                displayingmessage = displayingmessage.invert();
                if (displayingmessage) {
                    _sys.showcursor(true);
                    displaymessage(msgbase);
                    showelement(i,j, off_x, off_y);
                }
                else {
                    _sys.showcursor(false);
                    clearzonemessage();
                }
                used = true;
            }
            18: { //ctrl-r
                inputkey="Size";
                inputvalue=inputs[inputkey];
                field = true;
                used = true;
            }
            19: {//ctrl-s
                used = true;
                inputvalue=inputs["File"];
                if (inputvalue != "") {
                    writetable(inputvalue);
                    initvalue();
                    showelement(i,j, off_x, off_y);
                }
                else {
                    field = true;
                    inputkey="File";
                }
            }
            20: { //ctrl-t
                field = true;
                used = true;
                inputkey="Column";
                inputvalue=inputs[inputkey];

            }
            21: {
                displayhelp(helpmsg); //ctrl-u
                disphelp = true;
                used = true;
            }
            23: { //ctrl-w
                field = true;
                used = true;
                inputkey="File";
                inputvalue=inputs[inputkey];
            }
            24: { //ctrl-x
                //Moving a group of cells
                if (tracking) {
                    inputkey = "Moving";
                    inputvalue="from: "+firstclickx+","+firstclicky+" up to "+lastselx+","+lastsely+" at ";
                    formi = firstclickx;
                    formj = firstclicky;
                    isselected = true;
                }
                else {
                    inputkey="Move";
                    inputvalue="from: "+I+','+J+" up to ";
                    formi = I;
                    formj = J;
                }
                field = true;
                used = true;
            }
        }
        if (used) {
            if (field)
                s = initfield();
            else
                s = _sys.getchar();
            continue;
        }
    }

    if (inputkey == "formula" and inputvalue.count('(') != inputvalue.count(")")) {
        currentkey = inputkey;
        currentvalue = inputvalue;
        buildingformula=true;
        if (!formi) {
            formi = I;
            formj = J;
        }
        displaymessage("Building: "+I+"_"+J);
    }
    elif (inputkey == "regular" and inputvalue[-1] != ";") {
        currentkey = inputkey;
        currentvalue = inputvalue;
        buildingformula=true;
        if (!formi) {
            formi = I;
            formj = J;
        }
        displaymessage("Building: "+I+"_"+J);
    }
    elif (!modifying) {
        if (buildingformula) {
            displaymessage("Building: "+formi+"_"+formj+": "+currentvalue);
        }
        elif (field)
            displayprompt(dsp + inputvalue);
    }

    //We clear the parenthesis balance highligthing, if it is present
    if (colorparenth in inputvalue) {
        inputvalue = inputvalue.replace(colorparenth,"");
        inputvalue = inputvalue.replace(colornrm,"");
    }

    //if the arrow keys have been pressed
    if (handlingarrows(s)) {
        //We are editing a field in the matrix
        //Usually a formula
        if (modifying) {
            displayprompt(dsp+inputvalue);
            _sys.row_column(codeline-1,dsp.size()+posinstring);
            s=_sys.getchar();
            continue;
        }

        if (buildingformula) {
            inputkey = currentkey;
            inputvalue = currentvalue;
            initvalue();
            showelement(i,j, off_x, off_y);
        }
        elif (field) {
            initcoords();
            inputkey = currentkey;
        }
        else {
            initvalue();
        }
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    //If it is a MOUSE ACTION
    if (_sys.ismouseaction(s)) {
        if (mousecontrol(s)) {
            if (modifying) {
                displaymessage("Modifying");
                displayprompt(dsp+inputvalue);
                _sys.row_column(codeline-1,dsp.size()+posinstring);
                s=_sys.getchar();
                continue;
            }
            //Specific case, we are adding some stuff to a formula
            if (buildingformula) {
                inputkey = currentkey;
                inputvalue = currentvalue;
                if (tracking) {
                    tracking = false;
                    inputvalue += makerange(firstclickx,firstclicky, lastselx, lastsely);
                    currentvalue = inputvalue;
                    i = formi - off_x;
                    j = formj - off_y;
                    initcoords();
                    showelement(i,j, off_x, off_y);
                    s=_sys.getchar();
                    fullselection(firstclickx,firstclicky,lastselx,lastsely,false);
                    continue;
                }
                else {
                    showelement(i,j, off_x, off_y);
                    s=_sys.getchar();
                    continue;
                }
            }
            elif (field) {
                initcoords();
                if (checkfield()) {
                    field = false;
                    initvalue();
                    displaymessage(msgbase);
                    showelement(i,j, off_x, off_y);
                    s=_sys.getchar();
                }
                else {
                    inputkey = currentkey;
                }
                showelement(i,j, off_x, off_y);
                s=_sys.getchar();
                continue;
            }

            initvalue();
            showelement(i,j, off_x, off_y);
            s=_sys.getchar();
            continue;
        }
        if (modifying) {
            displaymessage("Modifying");
            displayprompt(dsp+inputvalue);
            _sys.row_column(codeline-1,dsp.size()+posinstring);
            s=_sys.getchar();
            continue;
        }

        string dsp = I + "," + J + " " + inputkey + ": " + inputvalue;
        displayprompt(dsp);
        s=_sys.getchar();
        continue;
    }

    if (s == _sys_keybackspace) {
        if (modifying) {
            if (posinstring > 1) {
                inputvalue = inputvalue[:posinstring-2]+inputvalue[posinstring-1:];
                posinstring--;
            }
            displayprompt(dsp+inputvalue);
            _sys.row_column(codeline-1,dsp.size()+posinstring);
            s=_sys.getchar();
            continue;
        }

        if (tracking) {
            deletion(firstclickx+off_x,firstclicky+off_y, lastselx+off_x, lastsely+off_y);
            tracking = false;
        }
        else {
            //We delete one character at a time
            if (inputvalue != "") {
                inputvalue = inputvalue[:-1];
            }
            if (inputkey == "value") {
                if (inputvalue == "") {
                    v_matrix[I][J] = defaultvalue;
                    mat[I:J] = 0;
                }
                else {
                    v_matrix[I][J] = inputvalue;
                    mat[I][J] = inputvalue.float();
                }
            }
        }
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    if (s == _sys_keyescape) {
        if (field) {
            if (isselected)
                selection(formi, formj, false);
            initvalue();
            field = false;
        }
        else {
            inputvalue = backup;
            modifying = false;
            resetbuildingformula();
            updatevalue();
        }
        displaymessage(msgbase);
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    //recording our values after a CR
    if (s == "\n" or s == "\r") {
        if (field) {
            if (checkfield()) {
                field = false;
                initvalue();
                showelement(i,j, off_x, off_y);
                s=_sys.getchar();
            }
            continue;
        }

        if (modifying) {
            if (!buildingformula) {
                modifying = false;
                if (!checkformula()) {
                    if (inputkey == "formula") {
                        formulas.pop(ky);
                    }
                    elif (inputkey == "regular") {
                        regularformulas.pop(ky);
                    }
                    inputkey = "value";
                }
                else
                    resetbuildingformula();
            }
            else {
                modifying = false;
                if (checkformula()) {
                    resetbuildingformula();
                }
                else {
                    displaymessage("Cannot evaluate");
                    displayprompt(dsp+inputvalue);
                    _sys.row_column(codeline-1,dsp.size()+posinstring);
                    s = _sys.getchar();
                    continue;
                }
            }
        }
        elif (buildingformula) {
            inputvalue = currentvalue;
            inputkey = currentkey;
            if (!createrange()) {
                inputvalue = inputvalue.trim() + " mat["+I+":"+J+"] ";
                currentvalue = inputvalue;
            }
            I = formi;
            J = formj;
            i = I - off_x;
            j = J - off_y;
            showelement(i,j, off_x, off_y);
            s=_sys.getchar();
            continue;
        }

        if (isselected)
            selection(formi, formj, false);

        updatevalue();
        handlingarrows(_sys_keydown);
        initvalue();
        evaluation(off_x,off_y);
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    if (modifying) {
        inputvalue = inputvalue[:posinstring-1]+s+inputvalue[posinstring-1:];
        if (s == ')') {
            //highlighting matching parentheses
            int e = posinstring-1;
            while (e>0 and inputvalue[e:posinstring].count("(") != inputvalue[e:posinstring].count(")")) e--;
            inputvalue = inputvalue[:e]+colorparenth+inputvalue[e]+colornrm+inputvalue[e+1:];
        }
        else {
            sz = inputvalue.size();
            inputvalue = compactstring(inputvalue, posinstring);
            posinstring -= sz-inputvalue.size();
        }
        if (buildingformula)
            currentvalue = inputvalue;
        posinstring+ = s.size();
        displayprompt(dsp+inputvalue);
        _sys.row_column(codeline-1,dsp.size()+posinstring);
        s=_sys.getchar();
        continue;
    }

    if (s.size() > 2) {
        if (frompaste(s)) {
            showelement(i,j, off_x, off_y);
            s=_sys.getchar();
            continue;
        }
    }

    if (_sys.isescapesequence(s) or s[0].ord() < 32) {
        initvalue();
        showelement(i,j, off_x, off_y);
        s=_sys.getchar();
        continue;
    }

    inputvalue += s;
    if (s == ";" and inputkey == "regular") {
        i = formi - off_x;
        j = formj - off_y;
        initcoords();
        resetbuildingformula();
        displaymessage("Ready to compute: "+I+","+J);
    }
    elif (s == ")") {
        if (inputvalue.count('(') > inputvalue.count(")")) {
            //highlighting matching parentheses
            int e = inputvalue.size()-2;
            while (e>0 and inputvalue[e:].count("(") != inputvalue[e:].count(")")) e--;
            inputvalue = inputvalue[:e]+colorparenth+inputvalue[e]+colornrm+inputvalue[e+1:];
        }
        else {
            if (inputkey == "formula") {
                i = formi - off_x;
                j = formj - off_y;
                initcoords();
                resetbuildingformula();
                displaymessage("Ready to compute: "+I+","+J);
            }
        }
    }
    elif (inputvalue == "(") {
        //We are creating a formula
        inputkey = "formula";
        backup="";
    }
    elif (inputvalue == "=") {
        //we are creating a regular formula
        inputkey = "regular";
        backup="";
    }
    elif (inputvalue in ["_pi ","_phi ","_tau ","_e "])
        inputvalue = definedvalues[inputvalue];
    else {
        inputvalue = compactstring(inputvalue, inputvalue.size());
    }
    if (!field) {
        v_matrix[I][J] = inputvalue;
        mat[I][J] = inputvalue.float();
    }
    showelement(i,j, off_x, off_y);
    s=_sys.getchar();
    continue;
}

_sys.reset();


