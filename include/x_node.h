/*
 *  Tamgu (탐구)
 *
 * Copyright 2019-present NAVER Corp.
 * under BSD 3-clause
 */
/* --- CONTENTS ---
 Project    : Tamgu (탐구)
 Version    : See tamgu.cxx for the version number
 filename   : x_node.h
 Date       : 2017/09/01
 Purpose    : tokenization 
 Programmer : Claude ROUX (claude.roux@naverlabs.com)
 Reviewer   :
 */

/*
 
 IMPORTANT: This file should not be replaced with the one that is generated by compilateurC.py out of the BNF grammar...
 It adds a rule-based tokenizer, which the compilateurC.py lacks.
 
 */

#ifndef x_node_h
#define x_node_h

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ostream>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <algorithm>

#include <sys/stat.h>
#include "conversion.h"

typedef enum { PARTIAL, FULL } x_parsing_mode;

class x_node {
public:
    
    string token;
    string value;
    char init;
    vector<x_node*> nodes;
    long start;
    long end;
    bool recursive;
    
    x_node(bool rec = true) {
        recursive = rec;
        init = 0;
        start = 0;
        end = 0;
    }
    
    x_node(string a, string v, x_node* x = NULL) {
        recursive = true;
        token = a;
        value = v;
        init = 0;
        if (x == NULL) {
            start = 0;
            end = 0;
        }
        else {
            start = x->start;
            end = x->end;
        }
    }
    
    x_node(x_node* n) {
        recursive=n->recursive;
        token=n->token;
        value=n->value;
        init=n->init;
        start=n->start;
        end=n->end;
        for (long i=0; i<n->nodes.size();i++)
            nodes.push_back(new x_node(n->nodes[i]));
    }
    
    ~x_node() {
        if (recursive) {
            for (size_t i = 0; i < nodes.size(); i++)
                delete nodes[i];
        }
    }
    
    bool equal(x_node* n) {
        if (token == n->token && value == n->value && nodes.size() == n->nodes.size()) {
            for (long i = 0; i < nodes.size(); i++) {
                if (!nodes[i]->equal(n->nodes[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    
    void set(string& t, string& v) {
        token = t;
        value = v;
        init = 1;
    }
    
    
    char append(x_node* n) {
        if (n != NULL && (n->init == 1 || n->nodes.size() > 0)) {
            if (n->init == 1)
                nodes.push_back(n);
            else {
                for (size_t i = 0; i < n->nodes.size(); i++)
                    nodes.push_back(n->nodes[i]);
                n->nodes.clear();
                delete n;
            }
            return 1;
        }
        return 0;
    }
    
    void pop(int i) {
        while (i > 0) {
            x_node* n = nodes[nodes.size() - 1];
            nodes.pop_back();
            delete n;
            i--;
        }
    }
};

class x_couple {
public:
    long pos;
    int intoken;
    x_node* tree;
    string values;
    
    x_couple(long p, int itok, x_node* s, string& lret) {
        pos = p;
        intoken = itok;
        tree = s;
        values = lret;
    }
    void set(string& lret) {
        lret = values;
    }
};

#endif



