# A WebAssembly implementation of Tamgu

Now you can enrich your JavaScript programs with Tamgu. We provide (see below) a _playground_ to test _Tamgu_ in your favorite browser. In particular, [index.html](https://github.com/naver/tamgu/tree/master/wasm/index.html) shows you how to integrate this library in your code.

## What is WebAssembly?

JavaScript has some limitations, despite significant progress, that make it unusable for some applications such as games or machine learning. The W3C has therefore proposed a new type of code: _WebAssembly_ to overcome these problems. WebAssembly is a binary format, a _bytecode_ that today's browsers can compile and execute. It works as an extension of JavaScript and can approach the performance of native applications, although according to some [studies](https://www.arxiv-vanity.com/papers/1901.09056/), performance is generally 10% to 60% slower than the corresponding C++ program. Above all, this _bytecode_ has now become a compilation target for the most common programming languages such as C++ or Java. Thus, taking an existing C++ code and compiling it into WebAssembly is now possible.


### Emscripten: C++ to WASM (WebAssembly)

There are several solutions for compiling to WebAssembly today, and one of the best known is [Emscripten](https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm). Emscripten is based on the LLVM compiler, but offers as a result not only a WASM (WebAssembly) library, but also HTML and JS files to use it.

This is the tool we used to transform Tamgu into a WebAssembly library. Note that we took inspiration from [_Pragmatic compiling of C++ to WebAssembly. A Guide._](https://medium.com/@tdeniffel/pragmatic-compiling-from-c-to-webassembly-a-guide-a496cc5954b8) to start this project.

## Compilation

We have successfully compiled a version of Tamgu into a WebAssembly library that can run on any web browser. However, we faced some challenges in porting Tamgu to WebAssembly, especially regarding strings handling.

### Output

The result of the compilation with Emscripten consists of a library `tamgu.wasm` and two files `tamgu.hmtl` and `tamgu.js`. We implemented a fourth file `tamgu_functions.js` to wrap the exported functions from the WASM library in JavaScript.

The `tamgu.js` file, which is generated by `emstdk` contains only the minimal code to load the library and initialize it. 

#### WASM Files

You can find all the necessary code in the [wasm](https://github.com/naver/tamgu/blob/master/wasm) directory:

* [tamgu.wasm](https://github.com/naver/tamgu/tree/master/binaries/wasm) is the WebAssembly library that enables you to run Tamgu code.
* [tamgu.js](https://github.com/naver/tamgu/tree/master/binaries/wasm/tamgu.js) handles the loading and initialization of the WebAssembly library.
* [tamgu_functions.js](https://github.com/naver/tamgu/tree/master/binaries/wasm/tamgu_functions.js) provides the JS wrappers to access the functions exported by tamgu.wasm.
* [index.html](https://github.com/naver/tamgu/tree/master/binaries/wasm/index.html) demonstrates how to integrate this library into a Web page with a basic interface for experimenting with the language.



## JavaScript API

This API has a key feature: it implements methods that return actual data structures that can be used directly in JS. These functions can return numerical values, strings or arrays of numbers and strings. They can also initialize variables within the interpreter. This is especially useful if you want to pass a large string or a large array to the code beforehand. Most of them take strings as input.

```Javascript
//See tamgu_functions.js
function callEval(code, size_output) //this function evaluates some tamgu code and returns a string

function callEvalToFloats(code, size_output_in_floats) //this function returns an array of Floats (Float64Array)
function callEvalAsInt(code) //this function returns an integer
function callSetqString(a_variable, value) //This function creates a variable whose value is a string 
etc.
```

We also added an additional function to clean the interpreter:

```Javascript
function callResetTamgu() //this function resets the tamgu interpreter
```

Note that the code and variables created in tamgu are _persistent_, hence the need to be able to regenerate the interpreter when needed. Thus, between two calls, the variables keep their value.


### Memory Usage

Firstly, it is important to note that WebAssembly operates within a sandbox environment, which ensures that memory cannot be corrupted or lost during program execution. To achieve this, the available memory must be defined when compiling WebAssembly using _emcc_. We compiled tamgu with the following values: 

```
INITIAL_MEMORY=47972352 
STACK_SIZE=20971520

47,972,352 corresponds to 732x65536 memory pages.
20,971,520 corresponds to 320x65536 memory pages.
```

It is essential to understand that this memory serves not only as the execution space for a WebAssembly program but also as the exchange area for functions exported by the library. Consequently, the arguments of WASM functions must be allocated within this specific memory space.

### Strings

One of the most challenging aspects of WebAssembly is that it requires strings to be passed as arrays of integers, where each character is encoded in UTF-16. Therefore, these arrays are first converted to UTF-32 strings in tamgu, since this is the basic encoding of strings in this language, and then if the output is also a string, they are converted back to arrays of integers.

We provide many different functions to encode and decode these arrays for _characters, integers and floats_.

```JavaScript
// Encodes a string into an integer array
const encode = function stringToIntegerArray(str, array) { ... };

// Decodes an integer array into a string
const decode = function integerArrayToString(array, sz) { ... };

// Provides characters as integers
function provideCharactersAsInts(code) { ... };

etc.
```

## Playground: _index.html_

We have provided an example of using this library in the `index.html` file.
You need first to launch a server.

#### Launching a server

Move to the directory where tamgu.wasm is located.

Execute:

```
emrun --port 8080 .
```

You can also use python:

```
python -m http.server --directory . 8080
````
Then you can use the address: `http://localhost:8080` in any browser to interact with tamgu.

### Running Code

As demonstrated, it is possible to interact with `tamgu.wasm` in a straightforward manner. You can add code, compile, and execute it on the fly. To re-execute code, simply position the cursor at the beginning of the line you wish to re-run.

![](https://github.com/naver/tamgu/blob/master/wasm/tamgu_wasm.png)

By default, the `callEval` method takes code and returns a string result. In many cases, this may be adequate, but it is also possible to return numeric values or lists of numeric values. You can even minimize compilation by initializing variables directly with lists or strings, for instance (see _callSetq_).

Referring to our previous example: `(geometric_distribution 20 0.3)`, it is possible to execute it in a way that returns a JavaScript _array_ or a string.

Note that in the GUI, the first case is covered by the button `As a list of integers`, while a simple call to `Reset/RUN` will return a string. Furthermore, the text area: `DATA` is automatically transformed into a variable of name `DATA` (sic) in the interpreter, with as value the content of this text area.

The underlying functions that are called are the following:


```Javascript
var result = callEvalToInts("geometric_distribution(20,0.3);", 1000), which gives: 8,0,4,1,0,2,2,2,4,1
```

while

```Javascript
var result = callEval("geometric_distribution(20, 0.3);", 1000), gives: "[2,1,0,1,1,0,0,11,5,11]"
```

requires us to parse the above string to extract the corresponding table.

### Persistence

Each call to a _callEval_ function keeps all the variables created in memory.
Thus, it is possible to chain the calls without losing the intermediate values:

```Javascript
(async () => {
    await callEval("int r = 100;", 1000)
    await callEval("r += 1000;", 1000)
    await callEval("println(r);",1000)
    await callEval("r", 100)
})();
```

Note two things about the code above:

1. The consecutive calls are _asynchronous_.
1. The last line executed in a code returns the final value of the evaluation, in this case `r` which is 1100

On the other hand, these variables exist only in the memory space of `tamgu.wasm`. This ensures the privacy of the processed data since the execution is local and does not pass through any server. The data is kept in the user's local memory and not in that of a remote server.

Of course, it is much more efficient to call `callEval` with the whole code at once. Still, the execution will return as a result the last line of the code.

## Conclusion

WebAssembly today offers JavaScript developers access to modules compiled in other languages such as C++, Rust or C#. Thanks to tools like _emsdk_, switching from C++ to WebAssembly code is relatively simple, although memory management and argument passing need some attention. Thus, we can offer a very interesting extension to JavaScript in the form of a tamgu interpreter, which complements JavaScript with a very rich set of instructions, especially for manipulating lists and strings, thanks to a tight integration.

Finally, the local execution of the code ensures the privacy of the user data and makes it easy to perform verifications or calculations in the browser without having to go through a server.

Tamgu is a very rich language as shown in the [English Documentation](https://github.com/naver/tamgu/blob/master/documentations/English/README.md) which offers developers other ways to design and implement their code for the Web.

 
 
